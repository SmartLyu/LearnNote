{"./":{"url":"./","title":"介绍","keywords":"","body":"YuaN 笔记 源位置： GitHub 加速位置： 国内私人地址 技术博客：CSDN 感悟想法 沟通 \\iff 传输 + 回馈 When Who in Where do What for Why, and How to solve. 生活数学式 (1.01)^{365} = 37.8 , (1.02)^{365} = 1377.4 (0.09)^{365} = 0.03 , (0.98)^{365} = 0.0002 积少成多，流沙易逝，所有的成败都取决于一个坚持，坚持积累，坚持不放纵自己才能成功。 \\lim_{t->now}{过程} = 行动 当时间无限趋近现在这个时间点，所谓过程 就是 当前做的行动 (过程 + 过去)' = 行动的结果 \\int (结果) + 过去 = 过程 过去 是一个常量 ， 而 整个进行了的过程​ 的导数(趋势) 就必然指向了​未来的结果 ， 而累计的无数已行结果 的积分就是 整个过程 综1、2上： 任何漫长的过程，都是无数有作为的行动组成的； 过程和结果没有重要性区别，已行过程决定未来结果，已有结果组成整个过程。 问题分析的泰勒公式 问自己一次 why 即一个高阶求导，公式如下： 问题 = Why + \\frac{Why(Why)}{1!} + \\frac{Why(Why(Why))}{2!} + \\frac{Why(Why(Why(Why)))}{3!} ... + o(why^n) (余项即累计经验) 反复问自己：\"这是为什么\"；得出结论后，在问：\"这又是为什么\" ，不断循环，就能分析清楚，而累计的经验即余项； 越多次反问、越丰富经验，就能更接近真相。 "},"Golang/":{"url":"Golang/","title":"Golang","keywords":"","body":"Go 基础 方法 数据结构 特殊处理 命令操作 单元测试 验证码 普罗米修斯 数据库 ES 参考文档 Golang Pkg "},"Golang/Basis.html":{"url":"Golang/Basis.html","title":"基础","keywords":"","body":"配置go环境 解压go包 配置GOPATH 如果需要下载包 golang.org/x/net/context --> github.com/golang/net/context goland(IDE)快捷操作 功能 操作 删除当前行 ⌘⌫ 行注释 ⌘/ 块注释 ⌥⌘/ 函数使用提示 ⌘P 代码检查并提供快速修复 ⌥⏎ 切换window ⌥⌘` 切换指定位置 ⌘⌥ 方向键 常用操作 swag swag init --parseDependency swag init mod go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct go mod init 包名 go mod download go mod vendor 导入包 集合导入包数据 import( \"fmt\" \"math/rand\" …… …… ) 包名 介绍 作用 fmt 基本包 用于输入输出 math 数学基本包 表内容 表内容 代码内容 "},"Golang/Function.html":{"url":"Golang/Function.html","title":"方法","keywords":"","body":"函数 函数名 作用 fmt.Println(String) 输出指定字符串 函数指定返回值 func 函数名(参数1，参数2 数据类型) (返回数据1,返回数据2 数据类型){ …… …… return } # example func add(x , y int) (y , x) { return } 函数值指定返回数据类型 func 函数名(参数1，参数2 数据类型) (返回数据1的类型,返回数据2的类型){ …… …… return 返回数据1 , 返回数据2 } # example func add(x , y int) (int , int) { return x + y , x } 函数返回值类型可以是func函数。 在函数中修改变量一般不影响全局的值，所以如果要改，必须传递一个指针进来，这个和C++相同 如果只返回一个返回数据，可以不写括号func 函数名(参数1，参数2 数据类型) 返回数据类型{……} 延迟函数 最后执行下面这个函数，多个defer的时候，是采用堆栈逻辑，原理是先进后出执行 defer 函数() 闭包 一个函数的返回值是一个函数。 原理：函数中回调一个子函数，可以理解为匿名函数，因为父函数被子函数依赖，所以其函数中定义的变量会一直存在内存中，每次调用函数后产生变化都是存在的。 可以把闭包理解为一个封装的环境中执行某个函数，每次定义一个变量存储这个环境，每次使用这个变量就是执行这个闭包中的子函数。 所以一般父函数中做的是环境定义，子函数做的是操作执行，如果定义两个变量，这两个变量中的值是相互不影响的。 对于执行的理解，可以是 f := function() 理解为执行父函数， f() 理解为执行子函数 func 函数名() func(参数类型) 返回值类型{ 相关操作1 return func(参数 参数类型) 返回值类型{ 相关操作2 return 返回值 } } # example func function() func() { a := 1 fmt.Println(\"只有第一次执行函数的时候才会触发\") return func(){ a ++ fmt.Println(\"每次执行这个函数都会执行，并且a变量值会一直存在\") } } # 定义一个变量存储这个函数 f := function() f() // 这就是执行一次闭包 闭包可以有值输入或输出 func function() func(int) int{ a := 1 fmt.Println(\"只有第一次执行函数的时候才会触发\") return func(x int) int{ a += x fmt.Println(\"每次执行这个函数吧输入的数加入\") return a } } # 定义一个变量存储这个函数 f := function() f(12) // 这就是执行一次闭包 变量 定义的所有变量都要被使用 ，否则会报错 变量类型设定 变量名1 变量类型1 , 变量名2 变量类型2 # 当变量类型相同的时候，等同如下 变量名1 , 变量名2 变量类型 # example x int , y int x , y int 定义变量 var 变量名1 , 变量名2 变量类型 # example var x , y bool 变量初始化赋值 var 变量名1 , 变量名2 变量类型 = 值1 , 值2 # 系统自动获取变量类型 var 变量名1 , 变量名2 = 值1 , 值2 # example var x , y int = 1 , 2 var x , y = 1 , 2 var ( x = 1 y = 2 ) 下面是简洁写法，但是不能在函数外使用 变量1 , 变量2 := 值1 , 值2 # example x , y := 1 , 2 变量类型 变量类型 含义 默认值 代表符号 bool 代表ture 或者 false false %t string 代表字符串 (空) %s int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr 整数类型 0 byte uint8 的别名 0 %d rune int32 0 %d float32 float64 浮点数 0 %f complex64 complex128 虚数 (0+0i) 特殊运算 > 所有二进制数向右移动n位 类型装换 表达式 T(v) 将值 v 转换为类型 T var i int = 42 var f float64 = float64(i) var u uint = uint(f) #string到int int,err:=strconv.Atoi(string) #string到int64 int64, err := strconv.ParseInt(string, 10, 64) #int到string string:=strconv.Itoa(int) #int64到string string:=strconv.FormatInt(int64,10) # byte到string str:=string(data) #string到float v2, err := strconv.ParseFloat(v, 64) 获取变量 test string flag.StringVar(&test, \"外部调用的名字\", \"默认值\", \"help提示文字\") flag.Parse() // 然后test变量就会通过外部获取值 解决没有输入参数的异常 if mip == \"Error\" || cip == \"Error\" || vip == \"Error\" { flag.Usage() return } 常量定义 const 常量1 , 常量2 = 值1 , 值2 # 可以大批量复制 指针 其零值是 nil *类型 指代某类型的指针 # example var i *int 那么 i 的值就是 nil ; 在不赋值去情况下使用 *i 会报告异常 循环 基本for循环 同C++的for for i := 初始值 ; i 初始值和数据变化模块不写 语法规则，同C++的while for i 死循环 for { } 用range和数组相结合 会遍历整个数组中所有元素，然后每次都会把一个数据给变量2，而变量1会每次+1 for 变脸1,变量2 := range 数组名{ …… …… } 变量1用来记录需要，可以不写 判断 if 判断语句 { } else { } 判断语句中可以有变量定义，例如： if err:=test();err != nil { } else { } switch - case switch i { case \"值1\": …… case 函数名(): …… defalut: …… } # "},"Golang/Structure.html":{"url":"Golang/Structure.html","title":"数据结构","keywords":"","body":"结构体 可以理解为一个自定义的数据类型 type 结构体名 struct{ 变量1 类型 变量2 类型 } # 使用方法 结构体.变量 结构体指针 结构体变量 := 结构体{值1,值2……} 指针名 := &结构体变量 # example a := add{1,2} b := &a b.x 的值就是1 go没有类的说法,但是可以就结构体进行函数方法的定义 语法类似于闭包，函数的返回值是一个函数。 func (结构体变量 结构体类型) 方法名() 返回值类型{ return 指定类型的值 } 结构体变量 := 结构体………… 结构体变量.方法名() # example type Vertex struct { X int Y int } func (v *Vertex) Abs() float64 { sum := v.X * v.X + v.Y * v.Y return math.Sqrt(float64(sum)) } func main() { v := Vertex{4,3} fmt.Println(v.Abs()) } 不光可以对自定义的结构体进行定义，也可以对数据类型，但是需要修改一个名字 type Vertex float func (v Vertex) Abs() float64 { return math.Sqrt(float64(v)) } 反射对象 var conf configJson // 反射对象configJson，遍历获取所有值 for i := 0; i 用于遍历一个对象内所有元素信息，进行相关操作 对象操作 // 为NatHostsMapType这个类定义Exist方法 func (m *NatHostsMapType) Exist(ht HostsTable) bool { m.Lock.Lock() defer m.Lock.Unlock() if _, isError := m.Data[ht.IP]; isError { return true } else { return false } } 数组 slice 其空值为 nil # 基本格式 数组名 []数据类型 # make创建一个数组格式 数组名 := make([]数据类型 , len初始值 ， cap初始值) # 新添加元素 数组名 = append(数组名,值1,值2) len默认值是0 , cap默认值是0 切片相关概念 len代表slice实际元素的个数； cap代表当前slice的容量 当len的长度不足够的时候，可以直接把数据存到容量中，如果达到初始设定容量，就会添加新加一个不比初始容量小的新容量，添加的容量无上限。 原则：cap>=len cap一定是偶数 cap要么和初始cap相同，要么是>=(cap初始值*2) 键名映射 一般和make连用，这个不要求有数据 数组名 = make(map[键名类型]数组类型) # 赋值的时候 数组名[任意键名] = 满足数组类型值 主要作用就是让数组的键名(下标)，可以被自定义 如果有数据 数组名 = map[键名类型]数组类型{ 键名1 : {值1 , 值2} 键名2 : {值1 , 值2} } 删除某键名的元素 delete(数组，键名) 查看某键名的元素是否存在 变量名 , 存储状态变量 := 数组名[键名] 变量名 , 存储状态变量 = 数组名[键名] 字符串相关操作 字符串截取 func TrimRight(s, cutset string) string TrimRight returns a slice of the string s, with all trailing Unicode code points contained in cutset removed. To remove a suffix, use TrimSuffix instead. 这个截取逻辑，是吧第二个字段内的所有字符从右向左依次匹配直到出现不匹配的字符停止 func TrimSuffix(s, suffix string) string TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged. 这个逻辑是删除最后符合第二个字符串的内容 两个区别很大，举例：TrimRight(\"abcdbcd\", \"bcd\") == \"a\" TrimSuffix(\"abcdbcd\", \"bcd\") == \"abcd\" "},"Golang/Dealway.html":{"url":"Golang/Dealway.html","title":"特殊处理","keywords":"","body":"接口 接口类型是由一组方法定义的集合。 接口类型的值可以存放实现这些方法的任何值。 但是不需要完成接口内方法的具体内容。 type 接口名 interface{ 方法名() 方法返回值 } 日志处理 var InfoLog *log.Logger file, err := os.OpenFile(UpdateLog(LogFileName), os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666) if err != nil { log.Fatalln(UpdateLog(LogFileName) + \" 文件无法打开\") } InfoLog = log.New(file, \"\", log.Ldate|log.Ltime|log.Lshortfile) Json处理 json文件结构体 type json结构体名 struct { 代表名1(开头大写) string `json:\"json名\"` 代表名2(开头大写) int `json:\"json名\"` } 将string解读为json数据 // 解析json格式的string信息 func ReadStringToJson(body string) json格式 { var jsonfile json格式 if err := json.Unmarshal([]byte(body), &jsonfile); err != nil { log.Fatal(err.Error()) } return jsonfile } 创建一个json文件 jsonfile := json格式 { 代表名1: \"值\", 代表名2: 值, ... } 将json格式转化为string func (mj json格式) ReadJson() (string) { js, _ := json.Marshal(&mj) return string(js) } 断言处理，获取需要的Json数据 func ReadProjectJsonString(jsonData string) { var v interface{} if err := json.Unmarshal([]byte(jsonData), &v); err != nil { log.Fatalln(err) } data, ok := v.(map[string]interface{}) if !ok { Log.Fatalln(\"解析失败\") return } data_2, ok := data[\"data\"].(map[string]interface{}) if !ok { Log.Fatalln(\"解析失败\") return } data_3, ok := data_2[\"data\"].([]interface{}) if !ok { Log.Fatalln(\"解析失败\") return } for k, v := range data_3 { fmt.Println(k, fmt.Sprintf(\"%v\",k)) } } 异常处理 if err := buildMha() ; err != nil { // 程序继续，中断函数 log.Panic(err) // 直接切断程序 log.Fatal(err) } 写文件 覆盖写 err := ioutil.WriteFile(\"test.txt\", []byte(\"Hi\\n\"), 0666) if err != nil { log.Fatal(err) } 追加写 func myWrite(config string, word ...string) error { for _, i := range word { f, err := os.OpenFile(config, os.O_WRONLY, 0644) if err != nil { fmt.Println(\"cacheFileList.yml file create failed. err: \" + err.Error()) return errors.New(i) } else { // 查找文件末尾的偏移量 n, _ := f.Seek(0, os.SEEK_END) // 从末尾的偏移量开始写入内容 _, err = f.WriteAt([]byte(i+\"\\n\"), n) } _ = f.Close() if err != nil { fmt.Println(\"cacheFileList.yml file writed failed. err: \" + err.Error()) return errors.New(i) } } return nil } "},"Golang/Linux.html":{"url":"Golang/Linux.html","title":"命令操作","keywords":"","body":"Linux ssh连接服务器 func connect(user, password, host, key string, port int, cipherList []string) (*ssh.Session,*ssh.Client, error) { var ( auth []ssh.AuthMethod addr string clientConfig *ssh.ClientConfig client *ssh.Client config ssh.Config session *ssh.Session err error ) // get auth method , 用秘钥或者密码连接 auth = make([]ssh.AuthMethod, 0) if key == \"\" { auth = append(auth, ssh.Password(password)) } else { pemBytes, err := ioutil.ReadFile(key) if err != nil { return nil, nil, err } var signer ssh.Signer if password == \"\" { signer, err = ssh.ParsePrivateKey(pemBytes) } else { signer, err = ssh.ParsePrivateKeyWithPassphrase(pemBytes, []byte(password)) } if err != nil { return nil,nil, err } auth = append(auth, ssh.PublicKeys(signer)) } if len(cipherList) == 0 { config = ssh.Config{ Ciphers: []string{\"aes128-ctr\", \"aes192-ctr\", \"aes256-ctr\", \"aes128-gcm@openssh.com\", \"arcfour256\", \"arcfour128\", \"aes128-cbc\", \"3des-cbc\", \"aes192-cbc\", \"aes256-cbc\"}, } } else { config = ssh.Config{ Ciphers: cipherList, } } clientConfig = &ssh.ClientConfig{ User: user, Auth: auth, Timeout: 30 * time.Second, Config: config, HostKeyCallback: func(hostname string, remote net.Addr, key ssh.PublicKey) error { return nil }, } // ssh 连接 addr = fmt.Sprintf(\"%s:%d\", host, port) if client, err = ssh.Dial(\"tcp\", addr, clientConfig); err != nil { return nil,nil, err } // create session if session, err = client.NewSession(); err != nil { return nil, client , err } modes := ssh.TerminalModes{ ssh.ECHO: 0, // disable echoing ssh.TTY_OP_ISPEED: 14400, // input speed = 14.4kbaud ssh.TTY_OP_OSPEED: 14400, // output speed = 14.4kbaud } if err := session.RequestPty(\"xterm\", 80, 40, modes); err != nil { return nil,nil, err } return session, client ,nil } const ( username = \"root\" password = \"\" key = \"/root/.ssh/id_rsa\" port = 22 ) func sshDoShell(ip string, cmd string) error{ ciphers := []string{} session, client, err := connect(username, password, ip, key, port, ciphers) if err != nil { fmt.Println(\"连接 \", ip, \" 异常\") log.Fatal(err) } defer func() { if err := session.Close(); err != nil { // log etc } }() defer func() { if err := client.Close(); err != nil { // log etc } }() session.Stdout = os.Stdout session.Stderr = os.Stderr err = session.Run(cmd) if err != nil{ return errors.New(err.Error()) } return nil } 执行shell命令 func myCmd(bash string, shell ...string) error { contentArray := make([]string, 0, 5) cmd := exec.Command(bash, shell...) stdout, err := cmd.StdoutPipe() if err != nil { fmt.Println(cmd.Stderr, \"error=>\", err.Error()) } _ = cmd.Start() reader := bufio.NewReader(stdout) contentArray = contentArray[0:0] var index int //实时循环读取输出流中的一行内容 for { line, err2 := reader.ReadString('\\n') if err2 != nil || io.EOF == err2 { break } fmt.Print(line) index++ contentArray = append(contentArray, line) } err = cmd.Wait() if err != nil { fmt.Printf(\"Execute Shell %s: \", shell) return errors.New(\"failed with error:\"+err.Error()) } return nil } 基于http协议的API接口实现 var ListenSig = make(chan int) type Route struct { Name string Method string Pattern string HandlerFunc http.HandlerFunc } type Routes []Route // 记录访问记录 func Logger(inner http.Handler, name string) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { start := time.Now() inner.ServeHTTP(w, r) File.WriteAccessLog(r.Method+\"\\t\"+r.RequestURI+\"\\t\"+name+\"\\t\"+time.Since(start).String()) }) } // 书写路由信息 func NewRouter() *mux.Router { router := mux.NewRouter().StrictSlash(true) for _, route := range routes { var handler http.Handler handler = route.HandlerFunc handler = Logger(handler, route.Name) router. Methods(route.Method). Path(route.Pattern). Name(route.Name). Handler(handler) } return router } var routes = Routes{ // 获取指定日期的监控信息 Route{ \"GetInfo\", \"GET\", \"/monitor/info\", ReturnMonitorInfo, }, // 收集监控数据并保存处理 Route{ \"MonitorCollect\", \"POST\", \"/monitor/collect\", PostMonitorInfo, }, } // 具体接口触发函数 func PostMonitorInfo(w http.ResponseWriter, r *http.Request) { } func ReturnMonitorInfo(w http.ResponseWriter, r *http.Request) { } // 启动api接口，port参数为暴露端口 func StartApi(port string) { router := NewRouter() File.WriteErrorLog(http.ListenAndServe(\":\"+port, router).Error()) ListenSig "},"Golang/Test.html":{"url":"Golang/Test.html","title":"单元测试","keywords":"","body":"go test 单元测试 go test -v ./... 读取目录下所有*_test.go文件，运行里面的test任务 每个包，都是从*Test.M出发 package api func TestMain(m *testing.M) { fmt.Println(\"Start test Api\") // 开始测试 m.Run() // 测试结束 fmt.Println(\"Finish test Api \") } func TestPostProjects(t *testing.T) { convey.Convey(\"测试\", t, func() { // start api and test convey.So(get_body, convey.ShouldEqual, right_body) }) } Mock方法 sqlMock goMock gomonkey gomonkey.ApplyFunc： mock某个方法 gomonkey.ApplyMethod： mock某个类的方法 xxx.Reset()： 重置各个方法 package api // 定义各个测试数据类型 var ( // 作为测试中传入的config值，这些信息会被mock掉 Api_test_cfg config.OctopusServerConfig // 作为测试中使用的project表信息 Api_test_projects []*mysql.Project ) func TestMain(m *testing.M) { // 启动api准备测试 patches := mockMysql() fmt.Println(\"Start test Api\") // 开始测试 m.Run() // 测试结束 for _, p := range patches { p.Reset() } fmt.Println(\"Finish test Api \") } // mock mysqlservice的相关操作 func mockMysql() map[string]*gomonkey.Patches { var ( // 作为数据库mock使用的对象 test_sql *mysql.Mysql patches = make(map[string]*gomonkey.Patches) ) // mock mysql func patches[\"GetMysqlInstance\"] = gomonkey.ApplyFunc(mysql.GetMysqlInstance, func(_ *config.DataSourceDetail) (*mysql.Mysql, error) { var dbConn *gorm.DB mysqlInstance := &mysql.Mysql{DbConn: dbConn} return mysqlInstance, nil }) // mock mysql method patches[\"GetProjects\"] = gomonkey.ApplyMethod(reflect.TypeOf(test_sql), \"GetProjects\", func(_ *mysql.Mysql) (interface{}, error) { return Api_test_projects, nil }) return patches } httptest 测试api接口的单元测试方法 package api // 定义各个测试数据类型 var ( // 作为测试中传入的config值，这些信息会被mock掉 Api_test_cfg config.OctopusServerConfig // api接口的使用对象 Apptest *iris.Application ) func TestMain(m *testing.M) { // 启动api准备测试 Apptest = CreateApi(&Api_test_cfg) fmt.Println(\"Start test Api\") // 开始测试 m.Run() // 测试结束 fmt.Println(\"Finish test Api \") } func TestPostProjects(t *testing.T) { convey.Convey(\"测试 post /projects\", t, func() { // start api and test e := httptest.New(t, Apptest) getAccess := e.POST(\"/projects\").WithHeader(\"traceid\", \"xxxx\").WithJSON(\"body\"). WithBasicAuth(Auth.Username, Auth.Password). Expect().Status(httptest.StatusOK) getAccess.Body().Equal(\"\") }) } Faker 随机生成相关参数，可以通过print dir(fake)，下面是相关列表 address : 962 Brown Mountain East Mary, CT 04738 am_pm : PM ascii_company_email : dawnhines@cantrell.com ascii_email : richardsanna@yahoo.com ascii_free_email : ejohnson@yahoo.com ascii_safe_email : steven92@example.org bank_country : GB bban : XRKR3466353844591 boolean : False bothify : 16 zD bs : harness cross-media web-readiness building_number : 2202 catch_phrase : Quality-focused solution-oriented hierarchy century : XII chrome : Mozilla/5.0 (Macintosh; Intel Mac OS X 10_5_0) AppleWebKit/5352 (KHTML, like Gecko) Chrome/40.0.802.0 Safari/5352 city : New Lisa city_prefix : Lake city_suffix : town color_name : Purple company : Gray and Sons company_email : martinallen@johnson.net company_suffix : and Sons coordinate : -87.141470 country : Northern Mariana Islands country_code : SO credit_card_expire : 12/27 credit_card_full : VISA 19 digit Adam Murphy 4436102807805944284 02/22 CVC: 607 credit_card_number : 3508735520995723 credit_card_provider : American Express credit_card_security_code : 129 cryptocurrency : ('BC', 'BlackCoin') cryptocurrency_code : DRC cryptocurrency_name : EOS.IO currency : ('RWF', 'Rwandan franc') currency_code : CHF currency_name : São Tomé and Príncipe dobra date : 2017-03-08 date_between : 2004-09-09 date_between_dates : 2019-01-02 date_object : 2016-06-06 date_of_birth : 1989-05-07 date_this_century : 2016-07-27 date_this_decade : 2015-06-18 date_this_month : 2019-01-01 date_this_year : 2019-01-01 date_time : 1998-05-01 17:23:46 date_time_ad : 0381-09-12 09:49:54 date_time_between : 2004-01-05 11:45:01 date_time_between_dates : 2019-01-02 20:42:43 date_time_this_century : 2008-12-05 18:31:25 date_time_this_decade : 2012-08-18 21:45:49 date_time_this_month : 2019-01-01 22:56:29 date_time_this_year : 2019-01-02 02:34:05 day_of_month : 09 day_of_week : Tuesday domain_name : mendoza.biz domain_word : zavala ean : 4633017886662 ean13 : 1212638242694 ean8 : 00511063 ein : 27-4912026 email : ruizpeter@hotmail.com file_extension : wav file_name : close.jpg file_path : /authority/section.mp4 firefox : Mozilla/5.0 (Windows NT 5.2; mn-MN; rv:1.9.1.20) Gecko/2016-07-12 09:28:12 Firefox/3.6.4 first_name : Brian first_name_female : Emily first_name_male : Robert free_email : toddedward@gmail.com free_email_domain : yahoo.com future_date : 2019-01-12 future_datetime : 2019-01-27 11:39:59 get_providers : [, , , , , , , , , , , , , , , , , , , , , ] hex_color : #63efde hexify : 333f hostname : srv-88.campbell.com iban : GB33UOJP7722297851032 image_url : https://placeimg.com/47/982/any internet_explorer : Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.1) ipv4 : 192.53.46.149 ipv4_network_class : a ipv4_private : 10.11.77.107 ipv4_public : 98.36.178.232 ipv6 : 9171:502a:4187:a38b:cab:2ae5:a008:3537 isbn10 : 1-84636-208-3 isbn13 : 978-1-80668-720-6 iso8601 : 1981-11-27T00:10:05 itin : 980-73-6362 job : Environmental health practitioner language_code : ha last_name : Harrison last_name_female : Dean last_name_male : Washington latitude : -71.7117395 latlng : (Decimal('-87.243354'), Decimal('68.383566')) lexify : ynqd license_plate : 04XI233 linux_platform_token : X11; Linux x86_64 linux_processor : i686 local_latlng : ('30.5427', '-97.54667', 'Hutto', 'US', 'America/Chicago') locale : tk_TM location_on_land : ('18.51957', '73.85535', 'Pune', 'IN', 'Asia/Kolkata') longitude : -149.969067 mac_address : f7:42:08:e8:c9:a5 mac_platform_token : Macintosh; PPC Mac OS X 10_6_3 mac_processor : U; Intel md5 : 7e7cb2e1d96aa3ea8af015bd7d21ae3c military_apo : PSC 3000, Box 1879 military_dpo : Unit 8330 Box 5496 military_ship : USNV military_state : AA mime_type : multipart/signed month : 07 month_name : August msisdn : 3162686718629 name : Melissa Gonzalez name_female : Annette Norton name_male : Justin Martinez null_boolean : True numerify : 110 opera : Opera/8.67.(X11; Linux i686; mai-IN) Presto/2.9.166 Version/10.00 paragraph : Less huge partner herself. Major career personal sort western impact. paragraphs : [u'Tonight else fear doctor. Radio past event garden.', u'Series technology section capital hundred go choice.', u'Large month resource concern Mr form machine. Simple site however watch.'] password : _NJnqyB+o8 past_date : 2018-12-03 past_datetime : 2018-12-29 23:03:20 phone_number : 001-810-068-3558x30683 postalcode : 63294 postalcode_plus4 : 24817-9240 postcode : 36965 prefix : Miss prefix_female : Miss prefix_male : Mr. profile : {'website': [u'http://knox.com/', u'https://hall-james.com/', u'https://gibbs.com/', u'http://gonzalez-pacheco.biz/'], 'username': u'hensonana', 'name': u'Timothy Strickland', 'blood_group': 'A+', 'residence': u'50459 April Dale\\nNorth Jasmine, IL 92057', 'company': u'Hays, Mcdonald and Costa', 'address': u'9407 Donna Summit\\nAnnetteville, WY 18513', 'birthdate': datetime.date(1980, 12, 19), 'sex': 'M', 'job': 'Engineer, site', 'ssn': u'170-61-7134', 'current_location': (Decimal('-42.5555445'), Decimal('42.848347')), 'mail': u'janetwalsh@gmail.com'} pybool : False pydecimal : -88679.375 pydict : {u'try': u'arthurday@hotmail.com', u'attorney': u'https://davis-shepherd.org/', u'beyond': u'AHMeTAiybSObDygFLCdP', u'make': Decimal('8.9'), u'sign': u'ugHKkPrnstWEoDyEWvmx', u'should': 9959, u'project': Decimal('-924424356.274'), u'born': u'kenHkltRzSJhjBZmvRaT', u'oil': u'xCFyZuRlAKZrvYkpSqxg', u'each': Decimal('61.99'), u'arrive': u'dHyljteKscrRHmswyaZU', u'minute': u'uZRBiOfKafHJcaaKXZXM'} pyfloat : -7651023230.8 pyint : 3534 pyiterable : [u'VHLKqNIghXURLCTtpzRn', Decimal('6012.9444191'), -35834818801.4104, 6171, Decimal('-12265352.2901'), 3595, u'https://www.salinas.biz/category.php', u'tmullen@harris.biz', datetime.datetime(2014, 6, 24, 0, 55, 42), -93.696436254134, u'NHntgKLcrlNkmEzlgNAR'] pylist : [u'jose07@yahoo.com', u'BgAbucmgaDtzDNkWHZxA', u'BGHXEbOTzWesohqDvSvd', datetime.datetime(1996, 7, 15, 11, 51, 9), u'rWVgMmfqZPaHMvIKXqbR', u'zachary98@yahoo.com', u'aPYhQZYdfMWLbegYpTrX', u'LBlIvbwnXKmfLscVFmyu', u'http://www.brown.com/homepage/', 2009, u'terri30@stafford-barnett.biz'] pyset : set([u'vtURKBQQRApIoUZROrll', 1105, u'jalvarado@gmail.com', u'QmqPChxAQibTqClxJhuD', datetime.datetime(2002, 8, 15, 23, 1, 56), Decimal('6.968001051'), 3837655878192.6, u'benjaminholloway@clark.com', -6306.918624, 3190, Decimal('-25374593628.5'), u'lgnXmYBtXNzCKpVvCYrb', Decimal('-33897542.763')]) pystr : LqxqCNVABxSlGFNkvrlx pystruct : ([u'jjkLtZqEljABLAkzTfUt', datetime.datetime(2008, 10, 8, 1, 50, 36), u'ZjEpHkuuMBAZkaBhQyrU', u'OilUAUmcThgkcxMbqSAh', datetime.datetime(1975, 7, 5, 0, 36, 55), u'fOJrQchzyPhFxqMdGMnE', 9250, 8949, u'sleWkpsNBMihVkGpRoot', Decimal('807164941.401')], {u'begin': u'BjbPTjfUvVfKcGiJMNQD', u'necessary': u'FzOHQMomtEMTgadZmixE', u'show': Decimal('53203338.7976'), u'country': u'swfMuAlLcqRLksRZwlyU', u'understand': u'lisalewis@mckay.org', u'rock': 9670.5514, u'close': 5565, u'east': 102813994221205.0, u'my': u'yPyrXsPeXixbldFbWhFU', u'those': u'efry@hotmail.com'}, {u'product': {4: u'patrickparker@hotmail.com', 5: [u'qCHqzUfasGcUMKjUhkLc', u'FxwucZAfcnYxrhqOOtXR', -395.803], 6: {4: u'aLqAwymVaNpmhyHhQOLH', 5: u'ErfioxhgoWNVCdnaVanq', 6: [u'RlnaSIsbWnKfaPViBLNj', u'jbTTgCCjCEtuzGodHAdV']}}, u'could': {0: u'RgwNMAMzXKlHhazdfhCX', 1: [u'EAUsPCgHgoQDJcblUCja', datetime.datetime(2012, 1, 19, 13, 35, 8), u'http://walters.org/explore/wp-content/app/author.htm'], 2: {0: u'lwPTuQsvNnCUPBBTffno', 1: u'eXQMtXfRtlBJfpVFAUjg', 2: [u'ECOKoifYhSzLoifZdWnl', u'https://johnson.net/category.html']}}, u'term': {8: datetime.datetime(2010, 1, 9, 12, 24, 49), 9: [datetime.datetime(2005, 11, 13, 14, 10, 18), 6119, u'rzsUSoLRotLlQSjzaskb'], 10: {8: u'belinda84@hotmail.com', 9: datetime.datetime(1997, 3, 10, 4, 46, 15), 10: [Decimal('663.0'), Decimal('6.83132854674E+13')]}}, u'environment': {1: u'qbWPXDBMWzHZELWxQBuz', 2: [6074, 3400, u'eHYTsFimBxNJryhThDNc'], 3: {1: datetime.datetime(1984, 4, 17, 4, 38, 31), 2: u'VhigpvUUAfCHutXcwfbX', 3: [u'UAjJhtniSwdhayTOLWEq', u'NrYZWiQYFJZMYmxiRLww']}}, u'rich': {9: u'UxqyzUuWWYhlsbfWtBPa', 10: [u'VvsHEFsWBmxlVzeCKMIX', 4015, datetime.datetime(1987, 5, 8, 6, 28, 31)], 11: {9: datetime.datetime(1994, 12, 29, 22, 3, 29), 10: u'IeVrPuRMbVQPQLpnXodo', 11: [u'YKUAepdkQNykJLtiEmeH', Decimal('86832605439.3')]}}, u'into': {8: [u'WFkKXgCihEjoMxPMpKiB', -371.213906693373, u'dbrowning@yahoo.com'], 9: {8: u'melissa96@hotmail.com', 9: [u'adamstammy@hotmail.com', 4613], 7: Decimal('-870.723488439')}, 7: u'https://anderson.com/'}, u'skill': {5: u'ZcQKPbNrKTKerNTBcOUu', 6: [1294, Decimal('532156.674'), 247], 7: {5: u'ZDVnfVsiIkWhZRhwhElc', 6: 3777, 7: [u'basssusan@barnett.com', u'gTRgZifCkCkKVgAoSuqm']}}, u'democratic': {2: u'https://gonzalez-dean.com/', 3: [u'millerrachel@schneider.com', u'FkpbQxHdbGinsxifzjLo', u'IPhyirwsceVwTKNpduNW'], 4: {2: u'AOOVvMWWxDyWBFYqZPZq', 3: u'PHdenfFfHQzsHrqmFFNJ', 4: [datetime.datetime(2006, 12, 10, 10, 21, 14), 7330]}}, u'themselves': {8: {8: [u'william87@yahoo.com', u'YRoBtIsJwgGXcuvpIJPj'], 6: 1245, 7: u'ygriffin@smith-rowe.com'}, 6: u'jefferyhall@yahoo.com', 7: [u'qherrera@hunt.info', u'andrewharvey@gmail.com', u'http://brown.info/list/wp-content/author/']}, u'today': {3: u'btSTHtwKXrLHvLpFKOVZ', 4: [u'https://www.ramirez.com/faq.php', u'dpsAElcgRCbovSDyVvdd', u'https://mcintosh-swanson.com/main/search/tag/terms/'], 5: {3: 9055, 4: datetime.datetime(1971, 7, 28, 12, 33, 9), 5: [u'danielhodges@fisher.com', u'EfuYhbcQKCQcptDTlmhM']}}}) random_choices : ['c'] random_digit : 6 random_digit_not_null : 8 random_digit_not_null_or_empty : 6 random_digit_or_empty : random_element : b random_elements : ['a'] random_int : 7153 random_letter : v random_letters : ['u', 'e', 'a', 'y', 'E', 'A', 'm', 'R', 'k', 'm', 'G', 'o', 'q', 's', 'l', 'O'] random_lowercase_letter : c random_number : 60 random_sample : ['b', 'a', 'c'] random_uppercase_letter : E randomize_nb_elements : 13 rgb_color : 207,33,21 rgb_css_color : rgb(141,14,63) safari : Mozilla/5.0 (Windows; U; Windows NT 6.0) AppleWebKit/535.12.3 (KHTML, like Gecko) Version/5.0 Safari/535.12.3 safe_color_name : olive safe_email : martinkayla@example.org safe_hex_color : #bb2200 secondary_address : Suite 437 seed : None seed_instance : sentence : Couple race sit sing TV. sentences : [u'Surface seem serve five each magazine.', u'Statement current line share force prevent company.', u'Daughter listen fear miss.'] "},"Golang/Captcha.html":{"url":"Golang/Captcha.html","title":"验证码","keywords":"","body":"数据存储 Redis 操作 type RedisStore struct { sync.RWMutex expiration time.Duration redisInstance *redis.Client } func NewRedisStore(expiration time.Duration, redisInstance *redis.Client) (r *RedisStore) { r = &RedisStore{ expiration: expiration, redisInstance: redisInstance, } return } func (this *RedisStore) Set(id string, value string) { this.Lock() defer this.Unlock() this.redisInstance.Set(context.Background(), id, value, this.expiration) } func (this *RedisStore) Verify(id, answer string, clear bool) bool { return this.Get(id, clear) == answer } func (this *RedisStore) Get(id string, clear bool) (value string) { this.RLock() defer this.RUnlock() var err error value, err = this.redisInstance.Get(context.Background(), id).Result() if err != nil { logger.Log.Errorf(\"从redis中获取 key `%s` 失败, %s\", id, err) return } if clear { this.redisInstance.Del(context.Background(), id) } return } Captcha 验证码 package api import ( \"github.com/kataras/iris/v12\" \"github.com/mojocn/base64Captcha\" \"image/color\" \"math/rand\" \"time\" ) var ( fonts = []string{\"DENNEthree-dee.ttf\", \"RitaSmith.ttf\", \"actionj.ttf\", \"chromohv.ttf\", \"wqy-microhei.ttc\"} defaultDigit = [...]interface{}{ base64Captcha.NewDriverDigit(80, 200, 4, 0.7, 80), base64Captcha.NewDriverString(80, 200, 0, base64Captcha.OptionShowHollowLine, 4, base64Captcha.TxtAlphabet, &color.RGBA{0, 0, 0, 0}, fonts), base64Captcha.NewDriverMath(80, 200, 0, 0, &color.RGBA{0, 0, 0, 0}, fonts), } ) func GetCaptcha() (string, string){ // 创建redis存储 store := NewRedisStore(5*time.Minute, redis.GetRedisInstance()) driver := defaultDigit[rand.Intn(len(defaultDigit))].(base64Captcha.Driver) captcha := base64Captcha.NewCaptcha(driver, store) uuid, b64s, err := captcha.Generate() if err != nil { CaptchaErr(ctx, err, response) return \"\", \"\" } return uuid, b64s } func validateCaptcha(key, value string) (validated bool) { if key == \"\" || value == \"\" { return } // 读取redis存储 store := NewRedisStore(5*time.Minute, redis.GetRedisInstance()) validated = store.Verify(key, value, true) return } "},"Golang/PrometheusExporter.html":{"url":"Golang/PrometheusExporter.html","title":"普罗米修斯","keywords":"","body":"普罗米修斯的采集模块 Exporter exporter主要职责是，数据采集上报，等待Prometheus按照任务拉取数据 引入官方库：github.com/prometheus/client_golang/prometheus 实现逻辑，是将Collector继承，改造其中的Describe和Collect方法，实现数据处理和录入，根据需求对不同LABEL传入不同值，可以灵活调整 // 根据继承的类 (下面命名为metrics) 创建出相关指标 metrics = &metrics{ metric: prometheus.NewDesc(\"指标名\", \"指标相关介绍\", []string{\"ACTIVE_LABEL\"}, prometheus.Labels{\"STATIC_LABEL\": \"静态值\"}), } registry := prometheus.NewPedanticRegistry() registry.MustRegister(metrics) // 调起 http api 可以通过 localhost:port/metrics 访问获取的各个指标的值 http.Handle(\"/metrics\", promhttp.HandlerFor( registry, promhttp.HandlerOpts{}, )) log.Printf(\"Now listening on: http://localhost%s \\nApplication started. Press CMD+C to shut down.\", *listenAddress) err := http.ListenAndServe(*listenAddress, nil) if err != nil { log.Fatal(\"collector 运行失败 ...\", err) } Demon package collector import ( \"github.com/prometheus/client_golang/prometheus\" ) type metrics struct { metric *prometheus.Desc } //Each and every collector must implement the Describe function. //It essentially writes all descriptors to the prometheus desc channel. func (collector *metrics) Describe(ch chan "},"Golang/Mysql.html":{"url":"Golang/Mysql.html","title":"数据库","keywords":"","body":"数据库 使用gorm类库作为数据库操作方法 通过全局对象CmdbInstance调用对数据库的操作 使用Get方法后，即会和数据库保持连接 使用抽象类CmdbService统一接口，后面再实现该类的方法即可 var ( mysqlInstance *Mysql CmdbInstance CmdbService ) type Mysql struct { DbConn *gorm.DB } // 抽象类 type CmdbService interface { Create(data *Struct) error Delete(Id uint) error Update(data *Struct) error Get(Id uint) (*Struct, error) } // 获取cmdb实例,默认是mysql func GetCmdb(cmdbCfgData *config.DataSourceDetail) (CmdbService, error) { cmdbDriver := cmdbCfgData.Driver var err error switch strings.ToLower(cmdbDriver) { case \"etcd\": return nil, nil default: CmdbInstance, err = mysql.GetMysqlInstance(cmdbCfgData) if err != nil { return nil, err } } return CmdbInstance, nil } // mysql建立连接的方法 func GetMysqlInstance(cmdbCfgData *config.DataSourceDetail) (*Mysql, error) { db_conn_string := fmt.Sprintf(\"%s:%s@tcp(%s:%d)/%s?charset=%s&parseTime=True&loc=Local\", cmdbCfgData.User, cmdbCfgData.Password, cmdbCfgData.Host, cmdbCfgData.Port, cmdbCfgData.Db, cmdbCfgData.Charset) dbConn, err2 := gorm.Open(\"mysql\", db_conn_string) //defer db.Close() if err2 != nil { return nil, err2 } dbConn.SingularTable(true) mysqlInstance = &Mysql{DbConn: dbConn} sqlDB := dbConn.DB() // SetMaxIdleConns 设置空闲连接池中连接的最大数量 sqlDB.SetMaxIdleConns(cmdbCfgData.IdleConnections) // SetMaxOpenConns 设置打开数据库连接的最大数量。 sqlDB.SetMaxOpenConns(cmdbCfgData.MaxConnections) // SetConnMaxLifetime 设置了连接可复用的最大时间。 sqlDB.SetConnMaxLifetime(time.Hour) logger.Log.Infof(\"连接数据库 %s ，空闲连接数 %d ， 最大连接数 %d\", cmdbCfgData.Host, cmdbCfgData.IdleConnections, cmdbCfgData.MaxConnections) return mysqlInstance, nil } 增 func (this *Mysql) Create(data *Struct) error { db := this.DbConn.Create(data) return db.Error } 改 func (this *Mysql) Update(data *Struct) error { _data, err := this.GetDevelopmentProductVersionbyId(data.Id) if err != nil { return err } db := this.DbConn.Model(_data).Updates(data) return db.Error } 删 func (this *Mysql) Delete(Id uint) error { db := this.DbConn.Delete(Struct{}, \"id = ?\", Id) return db.Error } 查 func (this *Mysql) Get(Id uint) (*Struct, error) { var data Struct db := this.DbConn.Where(&Struct{Id: Id}).Find(&data) return &data, db.Error } 空值 对于grom而言，string的\"\"、int的0、bool的false都是空值，如果结构体的对象中，存在空值，对数据库的修改的时候会忽略掉，如果想将空值写入数据库，需要改用map的方法 _data := make(map[string]interface{}) _data[\"key\"] = false //零值字段 db = this.DbConn.Model(Struct{}).Where(\"id = ?\", data.Id).Updates(_data) "},"Golang/Elastic.html":{"url":"Golang/Elastic.html","title":"ES","keywords":"","body":"ES日志分析 Elastic 使用类库github.com/elastic/go-elasticsearch/v5 定义连接方法 type ClientSet struct { c *elasticsearch.Client url string username string password string } type Request struct { Index string DocType string QueryString string Timeout time.Duration StartTimestamp string EndTimestamp string ScrollId string Size int } func NewClient5(address []string, username, password string) (es *ClientSet, err error) { _es, err := elasticsearch.NewClient(elasticsearch.Config{Addresses: address, Username: username, Password: password}) if err != nil { return nil, err } es = &ClientSet{ c: _es, url: address[0], username: username, password: password, } return } func getSearchUrl(baseUrl, index string) string { baseUrl = strings.Trim(baseUrl, \"/\") return fmt.Sprintf(\"%s/%s/_search?scroll=1m\", baseUrl, index) } // http请求es的接口 func (client *ClientSet) TermQuery(r *Request, terms map[string]string) (int, []byte, error) { queryBody, err := getTermQueryBody(r, terms) if err != nil { return 0, nil, err } return utils.HttpGet(getTermQueryUrl(client.url, r.Index), client.username, client.password, r.Timeout, map[string]string{\"Content-Type\": \"application/json\"}, queryBody) } 使用的获取Es的指定索引的方法 func GetEsIndex() { es, err := elasticsearch.NewClient5([]string{url}, Username, Password) if err != nil { errlog := fmt.Sprintf(\"连接 ES %s 失败, 异常信息为: %v\", url, err) log.Fatalln(errlog) return } code, body, err := es.TermQuery(&elasticsearch.Request{ Index: index, StartTimestamp: \"now-1h\", EndTimestamp: \"now\", }, map[string]string{ \"level\": \"error\", }) if err != nil { errlog := fmt.Sprintf(\"获取 ES %s 信息失败, 异常信息为: %v\", url, err) log.Fatalln(errlog) return } if code != 200 { errlog := fmt.Sprintf(\"请求 %s index 返回结果不是200, 异常信息为: %s\", index, string(body)) log.Fatalln(errlog) return } logger.Log.Infof(\"连接 ES %s 成功, 获取 %s index 成功\", url, index) list, err := assertion(string(body)) return } json数据断言 获取ES接口的信息后，需要对json进行断言处理，获取其中参数信息，下面是一个例子 func assertion(jsonData string) (hitList []string, err error) { var ( v interface{} ) hitList = make([]string, 0, 0) err = errors.New(\"失败\") if err := json.Unmarshal([]byte(jsonData), &v); err != nil { log.Fatalln(err) } data := v.(map[string]interface{}) hits, ok := data[\"hits\"] if !ok { log.Fatalln(\"解析未找到hits字段, 异常信息为: %s\", jsonData) return } // 获取异常日志信息 hit, ok := hits.(map[string]interface{})[\"hits\"] if !ok { log.Fatalln(\"解析未找到hits-hits字段, 异常信息为: %s\", jsonData) return } for _, _hit := range hit.([]interface{}) { _source, ok := _hit.(map[string]interface{})[\"_source\"] if !ok { log.Fatalln(\"解析未找到hits-hits-_source字段, 异常信息为: %s\", jsonData) return } msg, ok := _source.(map[string]interface{})[\"msg\"] if !ok { stack, ok := _source.(map[string]interface{})[\"stack\"] if !ok { log.Fatalln(\"解析未找到hits-hits-_source-msg(stack)字段, 异常信息为: %s\", jsonData) return } hitList = append(hitList, stack.(string)) continue } hitList = append(hitList, msg.(string)) } err = nil return } "},"Python/":{"url":"Python/","title":"Python","keywords":"","body":"Python 基础 "},"Python/Basis.html":{"url":"Python/Basis.html","title":"基础","keywords":"","body":"总纲 python和yaml文件有些类似，缩进严格对齐，对于循环判断的控制影响范围就是根据空格缩进，一个缩进属于同一个级别。 变量 变量名 = 变量值 使用的时候直接用变量名代表即可 全局变量 global 变量名 主要是在函数中使用，让函数中操作的数可以在函数外使用 字典 {'key名1': '具体值1' ，'key名2': '具体值2' } # 调用的方法 设定一个变量d 存储这些字典值，在调用的时候 d[key名]就是key对应的具体值 类似json格式的数据存储格式， 使用del删除字典中的元素：del d[key名] 判断key名是否存在自低昂中：\"key名\" in d 循环与判断 if ( 判断命令 ): 成功后执行的 else: 失败后执行的 while 判断 : 成功后执行的 else: 失败后执行的 for i in 列表: i一次获取列表中的值并执行 else: i取完列表中所有值 生成连续数 rannge([起始数值,]停止数值[,步长]) 起始数值不一定比停止数值大，可以是降序排列， 起始数值默认是0，步长默认也是0 终断循环 continue 停止本次循环的后续命令，但是循环依旧进行 break 本次循环的后续命令，并停止所有循环操作 函数 定义函数 def 函数名( 形参1 = 默认值 ，形参2 , *不定长度形参 ， **字典式形参 ) : 执行的命令 # 调用方法 函数名(实参1，实参2,**{\"字典式实参名1\":\"具体值1\"，\"字典式实参名2\":\"具体值2\"}) 函数名(*(所有实参组成的元组)) 如果没有设定默认值，那么实参个数必须和形参个数完全一致 如果设置一个形参的默认值就要全部都设定默认值 所有实参组成的元组可以是一个变量，赋值后放入 不定长形参会获取除去前面设定个数的参数外的所有实参(不包括字典格式类型的数据) 特殊用法 # 先调用，再使用函数控制时间 import time time.sleep(1) "},"Git/":{"url":"Git/","title":"Git","keywords":"","body":"GIT 原理 操作 修改内容 历史 分支 远端 子模块 "},"Git/Principle.html":{"url":"Git/Principle.html","title":"原理","keywords":"","body":"Git的操作原理 介绍 一个gitlib服务器有远程的分支以及存储设备，客户端操作，首先是从远端分支将数据下载到本地分支，然后进行修改、添加、删除的相关操作，随后在本地的分支中进行一次添加暂存提交的操作，再将分支推送上传到远端服务器，最后进行多分支合并操作。 分支 对于分支，可以理解为创建一个账户，每个不同的分支都是不同的修改进度，但最后都要进行合并操作，合并到主线中，也就是master分支，这个分支在大部分情况下会有push限制，不允许进行push覆盖操作，只可以合并操作。 在本地git仓库中，HEAD是一个指针，他指的就是当前用户所在的分支，下面的所有操作在不具体的指定情况下，全部是在修改这个分支的内容。 逻辑 远程分支下载到本地分支 --> 本地文件修改 --> 本地暂存并提交 --> 上传到远端并请求合并 --> 远端合并分支 总结 用户在操作的时候，一般是在远端开创一个自己的分支，然后下载到本地进行修改，然后通过一系列操作推送到远端，远端进行数据整合，最后回归主线。 "},"Git/Operation.html":{"url":"Git/Operation.html","title":"操作","keywords":"","body":"Git的基本操作 克隆远端的git仓库到本地 git clone .../*.git 这一般是第一步操作，把远端数据拷贝到本地，然后进行相关操作。 查看文件状态 git status 出现如下，代表发现有个未暂存本地的文件 Untracked files: (use \"git add ...\" to include in what will be committed) 出现如下，代表发现文件已经暂存到本地了 Changes to be committed: (use \"git rm --cached ...\" to unstage) 比较简单的查看文件状态 git status -s 这个比较简单： 看到??代表一个新的文本，还没有暂存本地分支。 看到A代表已经暂存到本地分支了，但是没有提交。 看到M说明没有暂存到本地分支。 看到D说明文件以及被删除或被移到分支存储位置外。 看到R说明文件修改了位置或者修改了名字 如果有AM那么说明是暂存后又发生了修改，需要再次暂存该文件。 文件暂存和取消 git add 文件名 ## 将文件暂存 git reset 文件名 ## 取消文件的暂存 文件暂存是每次必须进行的操作，新建文件或者修改文件都需要先暂存文件。 查看文件修改情况 查看没有暂存到本地的文件和现在的文件有哪些修改的部分 git diff 查看当前暂存到本地的文件和远端存储的原件有哪些修改部分 git diff --staged 提交更新 这是将文件提交到本地磁盘完成存储 git commit -m '提交的相关信息' 可以跳过 add 步骤，直接编辑文件后提交到本地 git commit -m '提交的相关信息' -a 添加后就会发现文件状态没了，因为已经存到磁盘中了。 "},"Git/Change.html":{"url":"Git/Change.html","title":"修改内容","keywords":"","body":"Git修改文本内容 增删改都属于修改文本，赠包括新建文本、文本添加内容，删包括删除文本、删除文本内容，改包括修改文本位置、修改文本内容。 在此提醒一个注意事项，在修改了git分支的操作后必须要提交，只有当status没有数据的时候才算写完了。 增删改文本内容、新建文本 修改完文件，需要先暂存add本地，再提交commit到本地分支。 删除文本 删除本地文本后，我们会发现status得到的结构是 D ，那么我们就需要从git体系中删除 git rm 文件名 git rm -f 文件名 ## 将暂存区中的文件内容也会删除 要注意，本地文件修改存储位置，以及重命名都会当做是删除了一个文本，创建了一个新的文本，git中移动文件和修改文件名，需要用特殊的方法。 除了我们手动产出本地文件外，也可以通过git rm 文件的方法，这样本地文件，和git本地分支文件都会被删除 移动文本、修改文本名 这个是根据linux的操作特点，移动文本，可以指定移动后的文件名，这样也就可以实现修改文本名，不过需要进行提交操作 git mv 原文件地址/名字 新文件地址/名字 git commit -m '提交修改位置(名字)' "},"Git/History.html":{"url":"Git/History.html","title":"历史","keywords":"","body":"Git查看历史消息 查看提交历史 git log git log -p ## 显示历史提交对文件的变化情况 git log -p -数字n ## 查看最近的n次提交中的文件变化情况 查看所有分支的提交历史 (注意最新的提交在上面) git log --oneline --decorate --graph --all 进行撤销操作 git reset HEAD 文件 ## 将上一次的git操作撤回 git checkout -- 文件 ## 真正对文件有作用的撤销操作 这里建议，通git status查看该如何撤销，一般在文件上方都会写如何撤销该操作 "},"Git/Branch.html":{"url":"Git/Branch.html","title":"分支","keywords":"","body":"Git分支操作 查看当前所在分支 git branch * + 绿色字体 的那个分支就是当前所在分支 查看各个分支的同步情况 git branch -vv 查看每个分支现在的情况，如果需要同步远端的文件使用git pull origin master 创建分支 git branch 分支名 ## 注意这只是创建新的分支，不会切换分支 git checkout -b 分支名 ## 创建新的分支并且切换到新分支 切换分支 git checkout 分支名 这就是将HEAD指针指向新的分支，然后下面的所有操作都是对该分支进行的操作 删除分支 git branch -d 分支名 注意：这里删除分支的前提必须是，该分支已经合并到了master中 指定分支跟踪 当克隆一个仓库时，它通常会自动地创建一个跟踪origin/master的master分支 git checkout -b 创建到本地的分支 origin/远程分支 创建一个本地分支，一直跟踪一个远端分支，这个的主要作用是git pull后面不用跟参数了而已 "},"Git/Origin.html":{"url":"Git/Origin.html","title":"远端","keywords":"","body":"Git远端的相关操作 查看远端仓库的相关信息 git remote -v git remote show origin ## 查看当前如果和远端进行推送、拉取等操作的缩写命令的含义 将本地分支推送至远端分支 git push origin master:分支名 将远端分支同步到本地 git pull origin master(或者其他分支) 一般同步数据都是同步master的文件内容 切换至远端分支 git checkout -b 本地分支名 origin/远程分支名 "},"Git/Submodule.html":{"url":"Git/Submodule.html","title":"子模块","keywords":"","body":"Submodule 介绍 有种情况我们经常会遇到：某个工作中的项目需要包含并使用另一个项目。 也许是第三方库，或者你独立开发的，用于多个父项目的库。 现在问题来了：你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个。 我们举一个例子。 假设你正在开发一个网站然后创建了 Atom 订阅。 你决定使用一个库，而不是写自己的 Atom 生成代码。 你可能不得不通过 CPAN 安装或 Ruby gem 来包含共享库中的代码，或者将源代码直接拷贝到自己的项目中。 如果将这个库包含进来，那么无论用何种方式都很难定制它，部署则更加困难，因为你必须确保每一个客户端都包含该库。 如果将代码复制到自己的项目中，那么你做的任何自定义修改都会使合并上游的改动变得困难。 Git 通过子模块来解决这个问题。 子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。 创建 git submodule add https://URL 下载 git submodule init git submodule update 修改 vim .gitsubmodule vim .git/config git submodule sync "},"Web/":{"url":"Web/","title":"Web","keywords":"","body":"Web 基础 校验 表格 页内标签页 Api请求交互 按钮 布局 参考文档 Element 范例库 Ali矢量Icon库 "},"Web/Basis.html":{"url":"Web/Basis.html","title":"基础","keywords":"","body":"总体结构 组件及其关系 // header部分内容 // body部分内容 // 引用的Js、Ts的文件位置 .http-terminal { height: 100%; padding: 25px; } // css 内容 @Component({ name: 'TemplateConfig', components: {} }) export default class TemplateConfig extends Vue { created() { // 页面初始时候会调用 } } 常用模块 watch 监听某个数据是否发生变化，如果变动执行指定函数 @Watch('Id') changeId(newVal: string, oldVal: string) { //需要操作的内容 } 等待并发执行 使用async、await，控制函数，等待指定任务完成后在执行，一般是将异步任务顺序执行 async A(){ await this.B() this.C() } "},"Web/Validate.html":{"url":"Web/Validate.html","title":"校验","keywords":"","body":"校验 当表单内，有数据需要被校验的时候 在Vue的 form 中，添加 rules、model，在指定item中添加prop内容表示其规则的对象名 在Ts中，添加对象rules里面的对象内容，按照model+prop的值组合，必须一一对应 例如，下面例子中，传递的参数信息为updateTemplate.template.Name，modle为updateTemplate，prop为template.Name，在Ts中对象需要两层传递 注意： Ts中的对象内容必须和Vue中完全一致 validateData(rule: any, value: any, callback: any) { if (value == undefined){ callback() return } for (let oc in this.offendingCharacters) { console.log() if (value.indexOf(this.offendingCharacters[oc]) != -1) { callback(new Error('存在违法字符' + this.offendingCharacters[oc])); } } callback() } rules = { template: { AlertExpr: { type: 'string', required: true, validator: (rule: any, value: any, callback: any) => { this.validateData(rule, value, callback) }, }, AlertName: { type: 'string', required: true, validator: (rule: any, value: any, callback: any) => { this.validateData(rule, value, callback) }, }, } } "},"Web/Table.html":{"url":"Web/Table.html","title":"表格","keywords":"","body":"表格 详细请查看官方文档，下面只列举几个特殊使用场景 选择某行进行操作 handleCurrentChange(val: any) { // 相关操作，val即为选中行的数据对象 } v-loading 为true的时候，表格中会有个圈圈在转，表示加载中 highlight-current-row 高亮选中的行 border 带有纵向边框 current-change 当选择的行变化的时候触发的函数 排序 按照一定规则要求，进行排序 sortString(value1: any, value2: any) { return value1.localeCompare(value2) } sortByName(row1: any, row2: any) { return this.sortString(row1.Name, row2.Name) } Vue中主要是table-column内的参数 sortable，表格中关于该列会有排序的标签按钮 sort-method，指定排序的函数 Ts中，需要制作函数，返回对比后是升序还是降序 "},"Web/Dialog.html":{"url":"Web/Dialog.html","title":"页内标签页","keywords":"","body":"业内标签页 在有内容需要修改的时候，需要在一个网页内弹出一个可操作展示的独立页面，详细内容 // 具体内容 update: any = { title: \"修改\", visible: false, data: {} } startUpdate(data: any) { this.update.visible = true this.update.data = data } finishUpdate() { this.updateRule.visible = false this.updateRule.data = {} } 默认visible为false，页面会被隐藏 通过调用startUpdate，将visible为true，页面即会出现 调用finishUpdate，关闭页面，并将数据格式化 "},"Web/Http.html":{"url":"Web/Http.html","title":"Api请求交互","keywords":"","body":"HTTP 前后端通信交互的使用方法 Axios axios({ baseURL: url, method: 'get', // 请求方法 data, // body信息 timeout: 300000, // request timeout }).then((res: any) => { // 请求后进行操作，res.data即返回的body信息 }.finally(() => { // 请求后无论成功与否执行的操作 }) axios是异步操作，请求发出后，会立刻执行，后面的代码，在请求返回后，执行then内的操作最后执行finally的操作 如果出现循环调用Api的情况，需要控制并发的相关操作，使用async、await 引用Request写法 // request.ts const service = axios.create({ baseURL: baseUrl, auth: { username: 'username', password: 'password' }, withCredentials: true, // send cookies when cross-domain requests timeout: 300000, // request timeout }) service.interceptors.response.use( /** * If you want to get http information such as headers or status * Please return response => response */ /** * Determine the request status by custom code * Here is just an example * You can also judge the status by HTTP Status Code */ response => { const res = response.data return res }, ) // A.ts A(){ request({ url: \"地址\", method: 'get', data }).then((res: any) => { // 操作 } } "},"Web/Button.html":{"url":"Web/Button.html","title":"按钮","keywords":"","body":"按钮 详细请查看官方文档，下面只列举几个特殊使用场景 常用参数 {{ data ? '点击 ' + data + ' 内容' : '请先选择' }} disabled 是否可以点击，为true的时候不可以呗点击 click 当点击的时候触发的函数 按钮二次确认弹框 主要使用方法popconfirm，详细链接位置 {{ '修改' }} confirm 点击确认后的函数 slot 必须为reference "},"Web/Div.html":{"url":"Web/Div.html","title":"布局","keywords":"","body":"布局 详细请查看官方文档，下面只列举几个特殊使用场景 row定义一行内的属性 gutter每列之间的间隔 col定义一列的属性 span 占整行的份额为多少，整行被分为24份，span=\"6\"代表占据四分之一 style内text-align 代表水平对齐方式，right右对齐，center居中，left左对齐 "},"Markdown/":{"url":"Markdown/","title":"超文本","keywords":"","body":"超文本 Markdown Adoc "},"Markdown/markdown.html":{"url":"Markdown/markdown.html","title":"Markdown","keywords":"","body":"标题 一级标题 ==== 二级标题 ---- ##二级标题 ####小标题 最多只有6个级别 粗斜体 *斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ***粗斜体文本*** ___粗斜体文本___ ~~删除文本~~ * 和 _ 一样的作用，依照个数进行不同的选择操作 链接 网址链接 [链接名称](http://链接网址) 引用 > 引用的话 可以换行继续操作，换行默认会自动在开头添加 > 只要中间没有中断那么引用也不会断 制表 | 该列表头 | 该列表头 | 该列表头 | |:------------- |:---------------:| -------------:| | 表内容 | 表内容 | 表内容 | | 表内容 | 表内容 | 表内容 换行内容| | 表内容 | 表内容 | ```代码内容``` | | Column 1 | Column 2 | Column 3 | |:------------- |:--------:| -------------:| | centered 文本居左 | centered 文本居中 | right-aligned 文本居右 | 分隔符 --- 在文本中需要分隔符的地方输入即可 符号转义 如果你的描述中需要用到 markdown 的符号，比如 # * 等，但又不想它被转义，这时候可以在这些符号前加反斜杠，如 \\ # * 进行避免。 列表 项目 项目 项目 项目1 项目2 项目3 [ ] 计划任务 [x] 完成任务 - 项目 * 项目 + 项目 1. 项目1 2. 项目2 3. 项目3 - [ ] 计划任务 - [x] 完成任务 链接 链接: [link](https://mp.csdn.net). 图片: ![Alt](https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg) 带尺寸的图片: ![Alt](https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg =30x30) 居中的图片: ![Alt](https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg#pic_center) 居中并且带尺寸的图片: ![Alt](https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg#pic_center =30x30) 注脚 一个具有注脚的文本。[^1] 随后换行写上 [^1]: 注脚的解释 字体颜色 内容 灰色 灰色 红色 红色 蓝色 蓝色 注释 Markdown将文本转换为 HTML。 *[HTML]: 超文本标记语言 LaTeX 数学公式 Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 是通过 Euler integral {% math %} \\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,. {% endmath %} 插入甘特图 gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划中 : des3, after des2, 5d 插入UML图 sequenceDiagram 张三 ->> 李四: 你好！李四, 最近怎么样? 李四-->>王五: 你最近怎么样，王五？ 李四--x 张三: 我很好，谢谢! 李四-x 王五: 我很好，谢谢! Note right of 王五: 李四想了很长时间, 文字太长了不适合放在一行. 李四-->>张三: 打量着王五... 张三->>王五: 很好... 王五, 你怎么样? 插入Mermaid流程图 graph LR A[长方形] -- 链接 --> B((圆)) A --> C(圆角长方形) B --> D{菱形} C --> D 插入Flowchart流程图 st=>start: 开始 e=>end: 结束 test=>condition: 测试 op=>operation: 我的操作 cond=>condition: 确认？ st->op->cond->test cond(yes)->test cond(no)->op 数学 特殊字符 \\begin{array}{|c|c|c|c|c|c|c|c|} \\hline {\\alpha} & {\\backslash alpha} & {\\theta} & {\\backslash theta} & {o} & {o} & {\\upsilon} & {\\backslash upsilon} \\\\\\\\ \\hline {\\beta} & {\\backslash beta} & {\\vartheta} & {\\backslash vartheta} & {\\pi} & {\\backslash pi} & {\\phi} & {\\backslash phi} \\\\\\\\ \\hline {\\gamma} & {\\backslash gamma} & {\\iota} & {\\backslash iota} & {\\varpi} & {\\backslash varpi} & {\\varphi} & {\\backslash varphi} \\\\\\\\ \\hline {\\delta} & {\\backslash delta} & {\\kappa} & {\\backslash kappa} & {\\rho} & {\\backslash rho} & {\\chi} & {\\backslash chi} \\\\\\\\ \\hline {\\epsilon} & {\\backslash epsilon} & {\\lambda} & {\\backslash lambda} & {\\varrho} & {\\backslash varrho} & {\\psi} & {\\backslash psi} \\\\\\\\ \\hline {\\varepsilon} & {\\backslash varepsilon} & {\\mu} & {\\backslash mu} & {\\sigma} & {\\backslash sigma} & {\\omega} & {\\backslash omega} \\\\\\\\ \\hline {\\zeta} & {\\backslash zeta} & {\\nu} & {\\backslash nu} & {\\varsigma} & {\\backslash varsigma} & {} & {} \\\\\\\\ \\hline {\\eta} & {\\backslash eta} & {\\xi} & {\\backslash xi} & {\\tau} & {\\backslash tau} & {} & {} \\\\\\\\ \\hline {\\Gamma} & {\\backslash Gamma} & {\\Lambda} & {\\backslash Lambda} & {\\Sigma} & {\\backslash Sigma} & {\\Psi} & {\\backslash Psi} \\\\\\\\ \\hline {\\Delta} & {\\backslash Delta} & {\\Xi} & {\\backslash Xi} & {\\Upsilon} & {\\backslash Upsilon} & {\\Omega} & {\\backslash Omega} \\\\\\\\ \\hline {\\Omega} & {\\backslash Omega} & {\\Pi} & {\\backslash Pi} & {\\Phi} & {\\backslash Phi} & {} & {} \\\\\\\\ \\hline \\end{array} \\delta \\Delta \\eta \\xi \\Lambda \\Sigma \\varepsilon \\mu \\vec{a} \\sum_{i=0}^n \\prod_{i=0}^n \\circ \\alpha \\theta o \\upsilon \\infty \\cup \\cap \\forall $\\pm $ $\\to$ $\\Rightarrow$ $\\iff$ \\beta \\vartheta \\pi \\phi $\\lim_{n\\rightarrow+\\infty}\\frac{1}{n(n+1)}$ \\gamma \\iota \\varpi \\varphi $\\forall$ $\\exists$ $\\neq$ $\\leq$ $\\geq$ \\delta \\kappa \\rho \\chi $\\sim$ $\\times$ \\cdot $\\in$ $\\notin$ $\\subset$ $\\subseteq$ $\\bigcup$ $\\bigcap$ $\\emptyset$ $\\not\\subset$ \\epsilon \\lambda \\varrho \\psi \\varepsilon \\mu \\sigma \\omega \\zeta \\nu \\varsigma \\eta \\xi \\tau \\Gamma \\Lambda \\Sigma \\Psi \\Delta \\partial \\Xi \\Upsilon \\Omega \\Omega \\Pi \\Phi {% math %}\\delta{% endmath %} {% math %}\\Delta{% endmath %} {% math %}\\eta{% endmath %} {% math %}\\xi{% endmath %} {% math %}\\Lambda{% endmath %} {% math %}\\Sigma{% endmath %} {% math %}\\varepsilon{% endmath %} {% math %}\\mu{% endmath %} {% math %}\\vec{a}{% endmath %} {% math %}\\sum_{i=0}^n{% endmath %} {% math %}\\prod_{i=0}^n{% endmath %} {% math %}\\circ{% endmath %} {% math %}\\alpha{% endmath %} {% math %}\\theta{% endmath %} {% math %}o{% endmath %} {% math %}\\upsilon{% endmath %} {% math %}\\infty{% endmath %} {% math %}\\cup{% endmath %} {% math %}\\cap{% endmath %} {% math %}\\forall{% endmath %} $\\pm $ $\\to$ $\\Rightarrow$ $\\iff$ {% math %}\\beta{% endmath %} {% math %}\\vartheta{% endmath %} {% math %}\\pi{% endmath %} {% math %}\\phi{% endmath %} $\\lim_{n\\rightarrow+\\infty}\\frac{1}{n(n+1)}$ {% math %}\\gamma{% endmath %} {% math %}\\iota{% endmath %} {% math %}\\varpi{% endmath %} {% math %}\\varphi{% endmath %} $\\forall$ $\\exists$ $\\neq$ $\\leq$ $\\geq$ {% math %}\\delta{% endmath %} {% math %}\\kappa{% endmath %} {% math %}\\rho{% endmath %} {% math %}\\chi{% endmath %} $\\sim$ $\\times$ {% math %}\\cdot{% endmath %} $\\in$ $\\notin$ $\\subset$ $\\subseteq$ $\\bigcup$ $\\bigcap$ $\\emptyset$ $\\not\\subset$ {% math %}\\epsilon{% endmath %} {% math %}\\lambda{% endmath %} {% math %}\\varrho{% endmath %} {% math %}\\psi{% endmath %} {% math %}\\varepsilon{% endmath %} {% math %}\\mu{% endmath %} {% math %}\\sigma{% endmath %} {% math %}\\omega{% endmath %} {% math %}\\zeta{% endmath %} {% math %}\\nu{% endmath %} {% math %}\\varsigma{% endmath %} {% math %}\\eta{% endmath %} {% math %}\\xi{% endmath %} {% math %}\\tau{% endmath %} {% math %}\\Gamma{% endmath %} {% math %}\\Lambda{% endmath %} {% math %}\\Sigma{% endmath %} {% math %}\\Psi{% endmath %} {% math %}\\Delta{% endmath %} {% math %}\\partial{% endmath %} {% math %}\\Xi{% endmath %} {% math %}\\Upsilon{% endmath %} {% math %}\\Omega{% endmath %} {% math %}\\Omega{% endmath %} {% math %}\\Pi{% endmath %} {% math %}\\Phi{% endmath %} 公式 公式： \\\\ \\mathbf{X} = \\left( \\begin{array}{ccc} x\\_{11} & x\\_{12} & \\ldots \\\\\\\\ x\\_{21} & x\\_{22} & \\ldots \\\\\\\\ \\vdots & \\vdots & \\ddots \\end{array} \\right) {% math %} 公式： \\\\ \\mathbf{X} = \\left( \\begin{array}{ccc} x\\_{11} & x\\_{12} & \\ldots \\\\\\\\ x\\_{21} & x\\_{22} & \\ldots \\\\\\\\ \\vdots & \\vdots & \\ddots \\end{array} \\right) {% endmath %} 矩阵 \\begin{matrix}1 & 2\\\\\\\\3 &4\\end{matrix} \\begin{pmatrix}1 & 2\\\\\\\\3 &4\\end{pmatrix} \\begin{bmatrix}1 & 2\\\\\\\\3 &4\\end{bmatrix} \\begin{Bmatrix}1 & 2\\\\\\\\3 &4\\end{Bmatrix} \\begin{vmatrix}1 & 2\\\\\\\\3 &4\\end{vmatrix} \\left|\\begin{matrix}1 & 2\\\\\\\\3 &4\\end{matrix}\\right| \\begin{Vmatrix}1 & 2\\\\\\\\3 &4\\end{Vmatrix} {% math %}\\begin{matrix}1 & 2\\\\\\\\3 &4\\end{matrix}{% endmath %} {% math %}\\begin{pmatrix}1 & 2\\\\\\\\3 &4\\end{pmatrix}{% endmath %} {% math %}\\begin{bmatrix}1 & 2\\\\\\\\3 &4\\end{bmatrix}{% endmath %} {% math %}\\begin{Bmatrix}1 & 2\\\\\\\\3 &4\\end{Bmatrix}{% endmath %} {% math %}\\begin{vmatrix}1 & 2\\\\\\\\3 &4\\end{vmatrix}{% endmath %} {% math %}\\left|\\begin{matrix}1 & 2\\\\\\\\3 &4\\end{matrix}\\right|{% endmath %} {% math %}\\begin{Vmatrix}1 & 2\\\\\\\\3 &4\\end{Vmatrix}{% endmath %} 积分 \\int_a^b f(x)\\mathrm{d}x \\int_a^b f(x)\\,\\mathrm{d}x {% math %}\\int_a^b f(x)\\mathrm{d}x{% endmath %} {% math %}\\int_a^b f(x)\\,\\mathrm{d}x{% endmath %} 根式 \\sqrt{2} \\sqrt{1+\\sqrt[p]{1+a^2}} \\sqrt{1+\\sqrt[^p\\!]{1+a^2}} {% math %}\\sqrt{2}分式 \\frac{x+y}{2} \\frac{1}{1+\\frac{1}{2}} {% math %}\\frac{x+y}{2}{% endmath %} {% math %}\\frac{1}{1+\\frac{1}{2}}{% endmath %} "},"Markdown/adoc.html":{"url":"Markdown/adoc.html","title":"Adoc","keywords":"","body":"AsciiDoc 官方参考文档 https://asciidoctor.cn/docs/asciidoc-syntax-quick-reference/ 开头 = 标题 Doc Writer v1.2, 2021-07-30 :toc: left :toclevels: :toc-title: :sectnums: :sectnums: 代表各级目录前加上序号 列表 * level 1 ** level 2 *** level 3 **** level 4 ***** level 5 链接 link:www.baidu.com[Baidu] 效果： Baidu 制表 |=== |Name of Column 1 |Name of Column 2 |Name of Column 3 |Cell in column 1, row 1 |Cell in column 2, row 1 |Cell in column 3, row 1 |Cell in column 1, row 2 |Cell in column 2, row 2 |Cell in column 3, row 2 |=== 效果： Name of Column 1 Name of Column 2 Name of Column 3 --- Cell in column 1, row 1 Cell in column 2, row 1 Cell in column 3, row 1 Cell in column 1, row 2 Cell in column 2, row 2 Cell in column 3, row 2 "},"SRE/":{"url":"SRE/","title":"运维","keywords":"","body":"SRE 系统 Jenkins Jenja2 Prometheus Kubernetes "},"SRE/System.html":{"url":"SRE/System.html","title":"系统","keywords":"","body":"系统 Mysql 查看mysql相关信息 查看数据库进程 ： show processlist; 或者 /work/servers/mysql/bin/mysqladmin -u root processlist 查看数据库事务信息 ： SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX; 查看当前锁定的事务 ： SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS; 查看当前等锁的事务 ： SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS; 查看所有表的大小： SELECT CONCAT(table_schema,'.',table_name) AS 'Table Name', CONCAT(ROUND(table_rows/1000000,4),'M') AS 'Number of Rows', CONCAT(ROUND(data_length/(1024*1024*1024),4),'G') AS 'Data Size', CONCAT(ROUND(index_length/(1024*1024*1024),4),'G') AS 'Index Size', CONCAT(ROUND((data_length+index_length)/(1024*1024*1024),4),'G') AS'Total'FROM information_schema.TABLES; 导库操作 Innodb表的导库操作 mysqldump -uroot -p -h127.0.0.1 --single-transaction --dump-slave=2 -B $db --tables 表名> /tmp/${db}.sql MyISM表的导库操作 mysqldump -uroot -p -h127.0.0.1 --lock-all-tables --dump-slave=2 -B $db --tables 表名> /tmp/${db}.sql Linux 升级内核 sudo wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh && sudo chmod +x bbr.sh && sudo ./bbr.sh 检查网络状态 Traceroute iperf mtr 时间同步 sudo ntpdate -u time.pool.aliyun.com 四层转发 ssh -C -f -N -g -L 0.0.0.0:中转端口:目的IP:目的端口 连接用户@中转IP "},"SRE/Jenkins.html":{"url":"SRE/Jenkins.html","title":"Jenkins","keywords":"","body":"Jenkins Jenkins迭代流程 GiteLab_jjb-template 存储了jenkins job的templete文件 根据tpl文件内的字段pipeline-scm，定义pipline文件的位置 SaaS的CI发布pipline文件位置 GiteLab_pipeline，其中有三个分支，master，ci，cd 根据job-template.id字段标识，在具体job信息中通过import方法调用 GiteLab_jjb存储了job文件，通过hook通知Jenkins_job-update调用进行配置信息的迭代，部分项目需要手动触发构建 Jenkins_job-update根据hook请求来的jenkins-jobs --conf jenkins_jobs.ini update --workers 5文件调用docker完成对Jenkins_work内job配置的更新 JJB基本原理 Jenkins Job Builder 基本组成原理 完整jenkins job组成 job配置文件，记录调用templete文件的id，env配置信息 - !include: jenkins/defaults.yml - !include: jenkins/templates/ci/template.yml - project: name: TEST folder: TEST jobs: - template_pipeline: job_name: '{folder}/{job_prefix}-test' env_vars: | key=value #!include: jenkins/templates/ci/template.yml 引用的的templete的文件位置 template_pipeline 调用的templete的id，即第八行 folder: TEST、env_vars: 都是配置信息 templete配置文件，记录调用pipline的相关信息 job-template: id: template_pipeline name: '{job_name}' project-type: pipeline description: '{description|sample}' git_branches: - ci pipeline-scm: scm: - git: url: '{git_server_base_url|http://GiteLab_pipeline/' branches: \"{git_branches}\" shallow-clone: true script-path: jenkinsfile/Jenkinsfile.{jenkinsfile} lightweight-checkout: true id: template_pipeline 作为templete的唯一标识id，用于job引用 pipeline-scm: 引用pipline的方法，目前采取的是调用 GiteLab_pipeline 的指定pipline配置文件 git_branches: 读取 GiteLab_pipeline的哪个分支，(master、ci 、cd) script-path: jenkinsfile/ci/Jenkinsfile.{jenkinsfile} 存储pipline的文件在git中的位置 pipline文件，实现指定的工作流流程 Jenkins的查看层级，server -> view -> project -> job Jenkins工作流基本方法 def node=\"\" if (env.node){ node =env.node }else{ node =\"develop\" } def maven_image=\"\" if (env.maven_image){ maven_image =env.maven_image }else{ maven_image =\"docker.io/maven:3.3.9\" } pipeline { agent {label node} agent {docker { image \"${maven_image}\" label node args \"${docker_args}\" }} options { timeout(time: 1, unit: 'HOURS') } stages { stage('delete workspace') { steps{ deleteDir() } } stage('checkout') { steps{ script{ } } } } stage('build') { steps{ script{ } } post{ always{ script{ if (env.DNET_PRODUCT){ build job: 'sourcecode_scan', parameters: [string(name: 'url', value: BUILD_URL),string(name: 'product', value: \"\")], wait: false } } failure{ script{ def subject = env.email_build_subject ? \"${env.email_build_subject}\" : \"构建失败-${env.JOB_NAME}\" def to = env.email_build_recipients ? \"${env.email_build_recipients}\" : \"heweiwei@hd123.com\" def body = env.email_build_body ? \"${env.email_build_body}\" : \"${env.JOB_NAME}构建失败,更多信息请查阅：${BUILD_URL}\" // send email emailext subject: subject, to: to, body:body,attachLog:true } } } } } post{ success{ script{ if (env.post_shell){ sh \"\"\" ${env.post_shell} \"\"\" } } } } } build job 调用创建新的job进行处理 triggerRemoteJob job 调用新job Jenkins on K8S pipeline是jjb从git上拉取的，所以在整理工作目录前，需要进行读取操作 在pipeline中创建一个template文件，link:https://devops-gitlab.hd123.com/hdops/jenkins_builder/-/blob/master/jenkinsfile/kubernetes_pod_template.yaml[范例] 去读配置后，清理目录，完成任务 def YAML_FILE=\"kubernetes_pod_template.yaml\" def docker_image=\"harbor.qianfan123.com/toolset/.....\" def label_name=\"jenkins-job-k8s\" def func = { echo \"1\" } pipeline { agent {label node} options { timeout(time: 3, unit: 'HOURS') } stages { stage('advance prepare on k8s to read yaml') { when { beforeAgent true environment name: 'on_k8s', value: 'True' } steps { script{ echo \"node : ${node}\" echo \"on_k8s : ${on_k8s}\" kubernetesPodYamlData = readYaml file: \"jenkinsfile/${YAML_FILE}\" kubernetesPodYamlData.spec.containers[0].image = \"${docker_image}\" kubernetesPodYamlData.spec.containers[0].name = \"${label_name}\" kubernetesPodYamlData.metadata.labels.label = \"${label_name}\" writeYaml file: \"${YAML_FILE}.tmp\", data: kubernetesPodYamlData kubernetesPodReadYamlData = sh(script: \"cat ${YAML_FILE}.tmp\", returnStdout: true) echo \"${kubernetesPodReadYamlData}\" } } } stage('delete workspace') { steps{ deleteDir() } } stage('修改版本信息 on k8s') { when { beforeAgent true environment name: 'on_k8s', value: 'True' } agent { kubernetes{ cloud 'kubernetes' yaml \"${kubernetesPodReadYamlData}\" } } steps{ script{ container(\"${label_name}\") { func() } } } } stage('修改版本信息 on docker') { when { beforeAgent true environment name: 'on_k8s', value: 'False' } steps{ script { sh \"docker pull ${docker_image}\" withDockerContainer(args: \"-v /root/.ssh:/root/.ssh\", image: \"${docker_image}\") { func() } } } } } } 函数书写方法 def func = { echo \"1\" } pipeline{ agent {label node} options { timeout(time: 3, unit: 'HOURS') } stages { stage('func') { steps{ script{ container(\"${label_name}\") { func() } } } } } } 发送邮件 emailext(recipientProviders: [[$class: 'RequesterRecipientProvider'],[$class: 'DevelopersRecipientProvider']],subject: \"${subject}\", body: \"${body}\",attachLog:true) RequesterRecipientProvider Jenkins的构建人信息 DevelopersRecipientProvider Git提交人信息 "},"SRE/Jinja2.html":{"url":"SRE/Jinja2.html","title":"Jinja2","keywords":"","body":"Jinja2 基础知识 Jinja2 需要至少 Python 2.4 版本来运行。此外，如果你使用 Python 2.4 ，一个可 以创建 python 扩展的可用的 C 编译器会为调试器安装。 当然大部分情况下是配合ansible使用 在线测试平台 ，参考文档 基本操作 判断 {% if a == b %} {{ a }} {% endif %} 循环 循环数组 {% for l in list %} {{ l }} {% endfor %} 循环字典 {% for k, v in dictory %} {{ k }}: {{ v }} {% endfor %} 多层循环 主要使用的是 loop 当前循环的相关信息 字符 内容 loop.index 当前循环迭代的次数（从 1 开始） loop.index0 当前循环迭代的次数（从 0 开始） loop.revindex 到循环结束需要迭代的次数（从 1 开始） loop.revindex0 到循环结束需要迭代的次数（从 0 开始） loop.first 如果是第一次迭代，为 True 。 loop.last 如果是最后一次迭代，为 True 。 loop.length 序列中的项目数。 loop.cycle 在一串序列间期取值的辅助函数。见下面的解释。 {% for l1 in list1 %} {% set outer_loop = loop %} {% for l2 in list2 %} {% if loop.index == outer_loop.index %} {{ l1 }}, {{ l2 }} {% endif %} {% endfor %} {% endfor %} 数组融合 {{ a | zip(b) }} 字典融合 {{ a | combine(b) }} 标准化 # 标准化为yaml类型 - {{ list | to_nice_yaml | indent(2) }} # 标准化为json类型 {{ list | to_nice_json }} "},"SRE/Prometheus.html":{"url":"SRE/Prometheus.html","title":"Prometheus","keywords":"","body":"Prometheus 基础架构 Exporter 外部的组件，可以自主开发，可以有很多功能 Node-Exporter，主要是监控主机的基础信息，是诸多监控插件中的一个，可以用来采集数据，将其暴露成metric供prometheus收集 Dingtalk-Exporter，接受请求发送给指定钉钉群，是诸多webhook处理插件中的一个，可以接受webhook请求，执行指定逻辑的任务 Consule-Exporter，注册中心，把各个Exporter注册进来，帮助prometheus发现各个服务方便pull信息 Prometheus Server 核心组件，收集、存储、检索、判断的模块 通过注册或者自主发现的Exporter中，pull监控指标数据 存储到指定位置也可以rewrite到其他地方，实现数据多点存储 通过PromQL查询，检索指定需求的监控信息 通过配置的rule判断是否需要报警 AlertManager 报警组件，通过接受prometheus的异常信息，根绝配置进行报警 内部概念： 主路由：没有子路由接受的异常，会根据主路由配置的接收组进行发送 路由：判断异常的信息，需要发给哪组接收组 接收组：路由发来请求后，发送异常到指定的邮件或者钉钉微信 结构拆分 新增概念 Prometheus group name: 组合rule，并以此作为rules的文件名，聚合配置 alert name: 和route一一对应的标识，多个rule可以配置一个alert name，这些将组合为一个报警发出 AlertManager global: 全局配置，包括alertmanager内的global、template、主路由的配置信息，记录方式是json的key-value村粗 routes: 路由配置，作为rule和receiver连接的配置，根据alertname，唯一匹配一组rule的报警，并路由给一组唯一命名为project+alertname的接收组 receivers: 接收组，根据主路由、子路由，发送报警给配置内的所有邮箱、钉钉群 Dingtalk-Exporter dingtalkUrl: 指代钉钉群的url webhookUr: 指代给recevier连接的url，其命名以webhook name生成 结构设计 一个项目，唯一对应一个prometheus、alertmanager、dingtalk-exporter 一个prometheus对应多个group name 一个group name对应多个alert name 一个alert name对应多个rule 一个rule对应一个表达式 一个alertmanager对应一个global配置 一个global内有多个route子路由 一个子路由匹配一个alert name下所有的rule 一个子路由对应一个receviers name 一个receviers name对应多个接收人，包括邮件、钉钉 一个dingtalk-exporter对应对应多个webhook name 一个webhook name对应一个webhook url，对应一个钉钉群 理论设计 协议约定： 一个project内，有且只有一个prometheus，且容器、配置独立相关无影响 一个project内只有，一个alertmanager、一组rule配置、一个dingtalk配置文件(其中可以有多条配置) 一个project内，一个rule对应一个route，匹配规则按照alert_name进行绑定 约定好，一个project下的dingtalk、alertmanager配置文件的存储位置 ruletemplate文件新增修改对线上已生成配置文件没有影响 表关联： global-route表和routes表，通过project关联，global-route与project一对一，routes与project是多对一 routes表和receiver_configs表，通过receiverId关联，routes与receiver_configs一对多 rules表中，根据group_name组合多条rule在一个文件中，并以此为文件名 生成alertmanager.yaml: 根据projectId信息，从global-route表中获取一条记录，其中有alertmanager.yaml需要的global、template、route字段内的基础信息 根据receiverId在receiver_configs表中获取多条记录，组合出receivers的一条配置 根据projectId信息，从routes表中获取多条记录，组合出在route.routes的基础信息， 根据其Id在receiver_configs表的receiverId找到多条记录 按照其中的type的值获取指定字段参数，组合出receivers内一条配置 修改信息: 以添加receiver为例，需要告知，project+ruleName两个信息以及添加的recevier的相关信息 根据信息，拼接处receiver_name，定位出routes表中一条记录 根据routeId在receiver_configs添加一条记录 以删除一个receiver为例，需要自行通过get查出Id信息 一般是从project+ruleName+email/webhook_url三个信息定位 根据Id定位一条记录，将之删除，再将route、receiver关联记录删除 问题： 如果修改yaml的结果不能被解析，是存起来作为一个特殊信息，还是将其判定为格式不正确 只能api修改 后续如果yaml格式发生调整，会出现所有版本都要迭代的问题 向下兼容 新增概念 Prometheus group name: 组合rule，并以此作为rules的文件名，聚合配置 alert name: 和route一一对应的标识，多个rule可以配置一个alert name，这些将组合为一个报警发出 AlertManager global: 全局配置，包括alertmanager内的global、template、主路由的配置信息，记录方式是json的key-value村粗 routes: 路由配置，作为rule和receiver连接的配置，根据alertname，唯一匹配一组rule的报警，并路由给一组唯一命名为project+alertname的接收组 receivers: 接收组，根据主路由、子路由，发送报警给配置内的所有邮箱、钉钉群 Dingtalk-Exporter dingtalkUrl: 指代钉钉群的url webhookUr: 指代给recevier连接的url，其命名以webhook name生成 逻辑结构 一个项目，唯一对应一个prometheus、alertmanager、dingtalk-exporter 一个prometheus对应多个group name 一个group name对应多个alert name 一个alert name对应多个rule 一个rule对应一个表达式 一个alertmanager对应一个global配置 一个global内有多个route子路由 一个子路由匹配一个alert name下所有的rule 一个子路由对应一个receviers name 一个receviers name对应多个接收人，包括邮件、钉钉 一个dingtalk-exporter对应对应多个webhook name 一个webhook name对应一个webhook url，对应一个钉钉群 功能设计 前端使用场景： 在页面A内，查看一个project下的rules，调用一个api，包括所有的rule，以及关联的所有recevier信息，可以对这些rules进行修改、删除 在页面A内，新建rules，可以选择使用template，如果选择一个，前端会将值注入各个框的默认值中，提交后，调用一个api，判断是否有alert_global，如果没有按照模板创建一个global，receiver信息，再根据结构添加rule 在页面A内，添加、修改、删除receiver，这个是在rule页面内，记录了id信息，进行相关增删改，暂时没有相关维度查询功能 在页面B内，查看、添加、修改、删除DingTalk相关配置，以及查看线上最新的配置文件内容 在页面C内，查看global相关信息，可以添加、修改、删除global相关配置 在页面D内，查看线上AlerManager最新配置文件信息、最新的rules配置文件信息 在页面E内，可以查看global_template相关配置，并修改 在页面F内，查看所有的ruletemplate，并可以进行修改 接口信息: 执行 alertmanager_config 配置文件的生成上传和下发 传入: projectId 执行: 读取global表、route表、receiver表，生成alertmanager.yaml，并上传到oss，调用excute下发获取并reload命令 ! 创建 alertmanager_config (被执行Api集成，不单独处理) 传入: alertmanager.yaml(string) 执行: 结构化string内的信息，存储到global表、route表、receiver表中 获取 alertmanager_config_global_template 传入: None 执行: 输出projectId为default值的global表和ReceiverId为default-main值的receiver表的信息 修改 alertmanager_config_global_template 传入: 结构体AlertGlobal以及结构体AlertReceiver(其中projectId为default) 执行: 入库 创建 alertmanager_config_global 传入: 结构体AlertGlobal以及结构体AlertReceiver 执行: 入库，触发alertmanager更新 获取 alertmanager_config_global 传入: projectId 执行: 输出projectId为projectId值的表信息 修改 alertmanager_config_global 传入: 结构体AlertGlobal 执行: 根据Id定位，修改表记录，触发alertmanager更新 删除 alertmanager_config_global 传入: Id 执行: 根据Id定位删除 创建 alertmanager_config_receiver 传入: 结构体AlertReceiver 执行: 入库 修改 alertmanager_config_receiver 传入: 结构体AlertReceiver 执行: 根据Id定位，修改表记录 删除 alertmanager_config_receiver 传入: Id 执行: 根据Id定位删除 获取rules_templates 传入: None 输出: 所有template结构信息，前端获取后落内存 创建rules_template 传入: 结构体PromeRuleTemplate 执行: 入库 删除rules_template 传入: Id 执行: 根据Id定位删除 修改 rules_template 传入: 结构体PromeRuleTemplate 执行: 根据Id定位，修改表记录 创建 rules 传入: 结构体PromeRule以及结构体AlertReceiver 执行: 查看是否有global表信息，没有则根据template创建一个，入库(rule和receiver)，根据ProjectId和AlertName创建对应的route，上传rule到oss，调用excute下发获取并reload命令，再触发alertmanager更新 获取rules 传入: ProjectId 执行: 输出projectId为projectId值的表信息，根据ProjectId和AlertName输出对应的routes，根据ReceiverId输出对应的receivers 修改 rules 传入: 结构体PromeRule 要求: 不能修改alertname 执行: 根据Id定位，修改表记录，上传rule到oss，调用excute下发获取并reload命令 删除rules 传入: Id 执行: 根据Id定位删除，根据ProjectId和AlertName删除对应的route，根据ReceiverId删除对应的receiver，调用excute下发删除指令并reload命令，再触发alertmanager更新 创建 dingtalk 传入: 结构体PromeRuleTemplate 执行: 入库，并上传oss，下发指令生效 获取 dingtalk 传入: ProjectId 执行: 输出projectId为projectId值的表信息 删除 dingtalk 传入: Id 执行: 根据Id定位删除，并上传oss，下发指令生效 修改 dingtalk 传入: 结构体DingtalkConfig 执行: 根据Id定位，修改表记录，并上传oss，下发指令生效 读取线上最新dingtalk配置文件 传入: projectId 执行: 获取dingtalk配置文件返回 读取线上最新prome_rules配置文件 传入: projectId 执行: 根据prometheus配置文件中的rule_files字段，读取所有文件内容组合返回 读取线上最新alertmanager配置文件 传入: projectId 执行: 获取alertmanager配置文件返回 "},"SRE/Kubernetes.html":{"url":"SRE/Kubernetes.html","title":"Kubernetes","keywords":"","body":"Kubernetes 命令合集 查看apiVersion、kind kubectl api-resources Deployment 配置文件写法 deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment spec: replicas: 1 selector: matchLabels: name: nginx strategy: rollingUpdate: maxSurge: 25% maxUnavailable: 25% type: RollingUpdate template: metadata: labels: name: nginx spec: containers: - image: nginx:1.18 name: nginx resources: limits: memory: 200Mi requests: memory: 100Mi cpu: 50m ports: - containerPort: 80 protocol: TCP volumeMounts: - mountPath: /usr/share/nginx/html/ name: config volumes: - name: config configMap: defaultMode: 0644 name: nginx-index metadata 描述信息 name 名字 lables 标签 spec 相关配置信息 replicas 副本数 strategy 更新策略 rollingUpdate 滚动更新 maxSurge 可以创建多少个新增的pod maxUnavailable 可以先停掉多少个pod不使用 selector 选择器 其中matchLabels - labels的值必须和template内的label是一致的 template 定义pod的模板 里面还有一组配置，这个是定义pod的 spec - containers 是pod中的容器信息 spec - containers - resources就是资源控制模块 spec - containers - ports为端口暴露情况，但是对外服务是service管理的 volumes 挂载存储管理 Service service.yaml apiVersion: v1 kind: Service metadata: labels: name: nginx name: nginx spec: type: ClusterIP ports: - name: nginx port: 80 selector: name: nginx spec - selector - name： 通过这个知道对应的pod的信息，这个里面的标签只要pod中包含就会获取到 spec - type： 指定service的模式 Configmap kubernetes可以根据需求获取配置 apiVersion: v1 kind: ConfigMap metadata: name: nginx-index data: index.html: | This is kustomize! Kustomize 通过工具，用于聚合deployment和service的配置，并且可以继承合并配置 整体结构 . ├── base │ ├── deployment.yaml │ ├── kustomization.yaml │ ├── rollout-transform.yaml │ └── service.yaml └── overlays ├── prod │ └── kustomization.yaml └── test └── kustomization.yaml 父类模块 在base目录中，通过kustomization.yaml，关联两个文件 apiVersion: kustomize.config.k8s.io/v1beta1 kind: Kustomization resources: - deployment.yaml - service.yaml configMapGenerator: - name: nginx-index files: - index.html configurations: - rollout-transform.yaml secretGenerator: - name: env-file-secret envs: - env.txt type: Opaque resources连接的deployment、service等文件信息 configMapGenerator 生成configmap的配置 configurations 可以让kustomize进行argo-rollout，官方下载yaml secretGenerator secret生成器，创建密码信息，如果overlay里面存在一样的名字会直接覆盖 envs 内容信息 type 加密方式 使用命令，合并生成配置 kustomize build 子类模块 以test环境为例，prod环境照例调整即可，在overlays/test目录中，继承的文件中，通过kustomization.yaml apiVersion: kustomize.config.k8s.io/v1beta1 kind: Kustomization resources: - ../base commonAnnotations: note: test commonLabels: environment: test namePrefix: test- nameSuffix: -suffix namespace: kustomize-test images: - name: nginx newName: httpd newTag: 'latest' configMapGenerator: - name: nginx-index behavior: replace files: - index.html secretGenerator: - name: env-file-secret envs: - env.txt type: Opaque patchesStrategicMerge: - deployment.yaml commonAnnotations deployment和service的metadata注释作用 commonLabels deployment和service的metadata统一新增的标签 namePrefix 、 nameSuffix deployment和service的metadata名字添加前后缀 namespace deployment和service的namespace统一修改 images 指定deployment中的template中的pod的镜像信息 configMapGenerator - behavior 这个behavior字段仅用于overlays中,有三种可选create|replace|merge create 当base不存在的时候必须选择这个 replace 当base存在这个配置的时候，直接替换base的值 merge 当base存在这个配置的时候，合并两个配置 patchesStrategicMerge 指定一个文件merge替换覆盖处理，可以添加deployment.yaml和service.yaml进行替换覆盖 下面举个例子，在overlays/test目录中新建一个deployment.yaml，即可用副本数修改为 apiVersion: apps/v1 kind: Deployment metadata: name: nginx spec: replicas: 5 strategy: canary: steps: - setWeight: 20 - pause: {duration: 10s} template: spec: containers: - name: nginx resources: limits: memory: 40Mi requests: memory: 20Mi cpu: 10m strategy - canary 进行灰度发布，需要在kubernetes中运行argo-rollout setWeight 一个批次的滚动的权重 pause 等待的时间，里面为{}空值即为一直等待 使用命令，合并生成配置 kustomize build --load-restrictor LoadRestrictionsNone overlays/test "},"MachineLearning/":{"url":"MachineLearning/","title":"人工智障","keywords":"","body":"机器学习 数据库 UI测试 基础 参考文档 视频地址 官网地址 课件地址 "},"MachineLearning/SQL.html":{"url":"MachineLearning/SQL.html","title":"数据库","keywords":"","body":"SQL 基础概念 DB，数据库，是存储数据的集合，即多个数据表 DBMS，数据库管理系统，例如oracle、mysql SQL的有关系型数据库，也有NoSQL的非关系型(键值型、文档型)数据库 执行流程 Oracle 语法检查：检查SQL的拼写是否有问题 语义检查：检查SQK中的对象是否存在 权限检查：判断用户是否有访问该数据的权限 共享池检查： 判断共享池中是否有缓存该语句的执行任务 如果有就进行软解析直接到执行环节 如果没有就需要进行硬解析，生成执行计划，进入优化环节，再进入执行 优化选择 减少硬解析的情况，具体方法：select * from A where id = 1 => select * from A where id = :id，这样每次修改变量进行软解析即可完成需求，但是这样的SQL优化会变困难 Mysql 采用C/S架构，整个有三层组成： 连接层：客户端和服务端建立连接的模块 SQL层 对SQL进行查询，这里的逻辑和存储方式没有关系 存储引擎层 存储引擎采用插件的形式，可以有InnoDB(支持事务、行级锁定、外键约束)、MyISAM(速度快、资源消耗小)等 流程 SQL语句 -> 缓存查询 -> 解析器 -> 优化器 -> 执行器 设计表的原则 主要是：三少一多的原则，核心即简单可复用 数据表个数越少越好 DBMS的和兴在于实体和联系的定义(E-R图)，数据表越少，代表联系的设定月简洁，方便理解和操作 字段个数越少越好 基础要求是每个字段相互独立，而不是通过其他字段计算出来的 字段个数越多，冗余可能性越大 联合主键越少越好 联合的主键越多，索引空间就需要更多，运行时间越久 主键和外键越多越好 关系越多，代表实体间的冗余度越低，利用率越高 不仅保证了表的独立性，还提高了关联利用率 查询语句 基础 select 字段 as 别名 from 表 where 条件 条件判断 比较运算符：=等于，!=不等 逻辑运算符： AND并且、OR或者 同时存在的时候，会先把AND逻辑完成再进行OR 小括号最内层的先处理 处理顺序，可以类比四则运算，AND就是乘法，OR就是加法 匹配： LIKE %部分值% 匹配所有包含这部分值的所有记录 去重 select distinct 字段1, 字段2 from 表 distinct 必须在所有的列明前面，如果放在中间或后面会报错 去重是对后面所有字段去重，只有选择的字段都相同的情况才会认定为重复 排序 select 字段 as 别名 from 表 where 条件 order by 字段 DESC order by 必须是最后一个子句，否则会报错 排序的顺序，可以在order后面注明，AES代表递增(第一行最小)，DESC代表递减(第一行最大) 排序可以写多个字段，排序会按照第一个字段排序后，相同字段再对第二个字段排序以此类推 分组 select 字段 as 别名 from 表 where 条件 group by 字段 having 条件 having和where类似，都是做数据条件判断的 having是在分组后做判断处理，所以先根据where筛选后分组，分组后的数据按照having再做判断 having可以使用集合函数而where不可以，例如sum、count、avg等 限制返回数量 select xxxx limit 10 执行顺序 关键字的排列顺序：select .. from .. where .. group by .. having .. order by .. 执行顺序： from -> where -> group by -> having -> order by -> limit "},"MachineLearning/Playwrite.html":{"url":"MachineLearning/Playwrite.html","title":"UI测试","keywords":"","body":"Playwrite https://playwright.dev/python/docs/intro "},"MachineLearning/Basis.html":{"url":"MachineLearning/Basis.html","title":"基础","keywords":"","body":"Machine Learning 基础概念 定义 在进行特定编程的情况下，给予计算机学习能力的领域。 一个程序被认为能从经验 E 中学习，解决任务 T，达到性能度量值P， 当且仅当，有了经验 E 后，经过 P 评判，程序在处理 T 时的性能有所提升。 主要类型 监督学习 无监督学习 强化学习 推荐系统 监督学习 Supervised Learning 回归问题：(线性规划) 离散数据计算出连续预测的值 分类问题：(线性回归) 通过多组数据，推算出离散值的出现情况 "},"Algorithm/":{"url":"Algorithm/","title":"算法","keywords":"","body":"算法整理 简单难度 解题详解 中等难度 解题详解 困难难度 解题详解 问题集合 题目 基础知识 基础知识 "},"Algorithm/Basic.html":{"url":"Algorithm/Basic.html","title":"基础","keywords":"","body":"基础知识 Redis的Hash存储 备忘链接 Hash存储 对于key、value的存储结构，将key进行求余的hash运算，得到整数，将其存放在哈希桶中，目的是更快的获取数据 如果出现多个key求得余数一样的时候，会在对应key中依链表的方式进行扩展，即一个桶中链住多个key rehash 主要目的，当桶内数据较多，链表过长，需要重新规划hash分布时候的使用方法 渐进式rehash，当新数据录入的时候，将数据在读出后，写入新的hash结构中，在不影响主业务的情况下，扩展到新的hash表中 进程、线程、协程 进程 进程是一种抽象的概念，进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。 进程有三态模型：运行、就绪和阻塞 五态模型新增：新建态和终止态 线程 线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。 协程 协程是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程，具有对内核来说不可见的特性。 进程和线程的区别 进程是资源分配的最小单位，线程是CPU调度的最小单位 进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存 一个线程只能属于一个进程，而一个进程可以有多个线程 进程切换的开销也远大于线程切换的开销 进程适应于多核、多机分布；线程适用于多核 线程和协程的区别 线程的切换由操作系统负责调度，协程由用户自己进行调度 多线程适用于大量计算的，但协程适用于被阻塞的，且需要大量并发的场景。 并发与并行 并发是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，也就是多个程序在一个cpu中轮流占用时间片 并行就是程序按照资源调度在不同的cpu中同时执行 "},"Algorithm/Question.html":{"url":"Algorithm/Question.html","title":"题目","keywords":"","body":"算法整理 Golang需要记忆的类库 堆栈 var stack *list.List = list.New()是栈的对象以及初始化 stack.PushBack(value)入栈 e := stack.Back(); stack.Remove(e);return e.Value.(int)出栈 stack.Len()栈的长度 字符串操作 strings.Split(s, \"\")字符切分为数组 strings.Join(list, \"#\")数组组合为字符串 strings.Replace(s, \"#\", \"\", -1)将字符串中指定子串替换 strings.Contains(s, \"a\")判断字符串中是否包含 哈希表操作 m = map[string]int 创建哈希表 delete(m, key)删除值 数组操作 sort.Ints(nums) 排序 a = append(a, b) 插入 sort.Slice(nums, func(i, j int)bool{return nums[i][0] 二维数组，以第一下标进行排序，func为排序判断大小的逻辑方法 简单难度 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 Example: 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 解题详解 用两个栈实现队列 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) Example: 输入： [\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[3],[],[]] 输出：[null,null,3,-1] 解题详解 最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 Example: 输入：strs = [\"flower\",\"flow\",\"flight\"] 输出：\"fl\" 解题详解 有效的括号 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 Example: 输入：s = \"()\" 输出：true 解题详解 移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 Example: 输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 解题详解 买卖股票的最佳时机 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 Example: 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 解题详解 中等难度 最长回文子串 给你一个字符串 s，找到 s 中最长的回文子串。 Example: 输入：s = \"babad\" 输出：\"bab\" 解释：\"aba\" 同样是符合题意的答案。 解题详解 无重复字符的最长子串 给定一个字符串 s ，请你找出其中不含有重复字符的 最长连续子字符串 的长度。 Example: 输入: s = \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子字符串是 \"abc\"，所以其长度为 3。 解题详解 两数相加 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 Example: 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807 解题详解 括号生成 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 Example: 输入：n = 3 输出：[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"] 解题详解 LRU 缓存 请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。 实现 LRUCache 类： LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。 Example: 输入 [\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] 输出 [null, null, null, 1, null, -1, null, -1, 3, 4] 解题详解 二叉树的锯齿形层序遍历 给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 Example: 输入：root = [3,9,20,null,null,15,7] 输出：[[3],[20,9],[15,7]] 解题详解 整数反转 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 Example: 输入：x = 123 输出：321 解题详解 三数之和 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 Example: 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 解题详解 搜索旋转排序数组 整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。 Example: 输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4 解题详解 字符串相乘 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。 Example: 输入: num1 = \"2\", num2 = \"3\" 输出: \"6\" 解题详解 最长连续序列 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 Example: 输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 解题详解 乘积最大子数组 给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 测试用例的答案是一个 32-位 整数。 子数组 是数组的连续子序列。 Example: 输入: nums = [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。 解题详解 岛屿数量 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 Example: 输入：grid = [ [\"1\",\"1\",\"1\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"0\",\"0\"] ] 输出：1 解题详解 最长递增子序列 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 Example: 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 解题详解 加油站 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。 Example: 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2] 输出: 3 解释: 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。 解题详解 合并区间 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 Example: 输入：intervals = [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 解题详解 困难难度 接雨水 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 Example: 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 解题详解 最小覆盖子串 K 个一组翻转链表 给 Example: 解题详解 "},"Algorithm/Easy.html":{"url":"Algorithm/Easy.html","title":"简单难度","keywords":"","body":"简单难度 两数之和 题目 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 用例 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 输入：nums = [3,2,4], target = 6 输出：[1,2] 输入：nums = [3,3], target = 6 输出：[0,1] 思路 遍历数据，将其存入hash表中，将原列表以值为下标，下标为值存表 这样当i和target - i两个下标都存在的时候，则为相同的目标值，每次判断目标值与当前值的差锁得的下标是否存在，如果存在，返回两个下标值，不存在则丰富列表 时间复杂度O(n)， 空间复杂度O(n) 答案 func twoSum(nums []int, target int) []int { hash_list := map[int]int{} for i, _num := range nums { if j, ok := hash_list[target-_num]; ok { return []int{j,i} } hash_list[_num] = i } return nil } 用两个栈实现队列 题目 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 用例 输入： [\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[3],[],[]] 输出：[null,null,3,-1] 输入： [\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 思路 栈，先进后出；队列，先进先出；如果一个栈导出到另一个栈，整体数据就是先进先出，和队列一致 A栈负责存储数据，当需要输出的时候，检查B栈中是否有数据，如果有则弹出，如果没有将A中所有数据存入B中再输出 举个栗子： 假设，进行下面三次操作 入1、2、3 出两次 那么 A栈中数据从上到下是，3、2、1 将A中数据到B中，B栈中数据从上到下1、2、3，那么这时候如果要输出数据B出栈即可 时间复杂度O(n)，空间复杂度O(n) 答案 type CQueue struct { stack1, stack2 *list.List } func Constructor() CQueue { return CQueue{ stack1: list.New(), stack2: list.New(), } } func (this *CQueue) AppendTail(value int) { this.stack1.PushBack(value) } func (this *CQueue) DeleteHead() int { if this.stack2.Len() == 0 { for this.stack1.Len() > 0 { this.stack2.PushBack(this.stack1.Remove(this.stack1.Back())) } } if this.stack2.Len() != 0 { e := this.stack2.Back() this.stack2.Remove(e) return e.Value.(int) } return -1 } 最长公共前缀 题目 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 用例 输入：strs = [\"flower\",\"flow\",\"flight\"] 输出：\"fl\" 输入：strs = [\"dog\",\"racecar\",\"car\"] 输出：\"\" 解释：输入不存在公共前缀。 思路 基础两个思路 横向比较，从第一个字符遍历整个数组，如果都有，则开始遍历第二个字符，知道有一个不符合的时候停止。(下面展示代码的逻辑) 纵向比较，以一个字符串为模型，第二个字符串从第一个开始比较，有相同的则保留，将保留下的字符串向后依次遍历，如果中途有一中情况字符串为空，则退出，最后得到结果 需要注意，判断是否相等前先判断index是否超出限制 时间复杂度O(mn)，空间复杂度O(1) 答案 func longestCommonPrefix(strs []string) string { ans := \"\" for i := 0; i = len(s) || Sam != s[i] { isSam = false break } } if isSam { ans += string(Sam) } else { break } } return ans } 有效的括号 题目 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 用例 输入：s = \"()\" 输出：true 输入：s = \"{[]}\" 输出：true 输入：s = \"(]\" 输出：false 输入：s = \"([)]\" 输出：false 思路 使用栈遍历存入字符，如果是左括号则入栈，右括号则出栈(如果栈中没数据立刻报错)，因为要求符合顺序，如果出栈的左括号和有括号不匹配则报错，如果匹配则继续遍历，最后如果栈中没有数据则通过，否则说明有不匹配的数据 需要注意，出栈前需要判断栈中是否有数据 时间复杂度O(n)，空间复杂度O(n) 答案 func isValid(s string) bool { if len(s) % 2 == 1 { return false } var ( stack = list.New() mapList = map[string]string{ \")\" : \"(\", \"]\" : \"[\", \"}\" : \"{\", } ) for _, _s := range strings.Split(s, \"\"){ if _s == \"(\" || _s == \"[\" || _s == \"{\"{ stack.PushBack(_s) } else if _s == \")\" || _s == \"]\" || _s == \"}\" { if stack.Len() == 0 { return false } e := stack.Back(); stack.Remove(e) if mapList[_s] != e.Value.(string) { return false } else { return false } } } if stack.Len() > 0 { return false } return true } 移除元素 题目 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i 用例 输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,4,0,3] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 思路 因为不关心数据，那么只需要找到目标值，把一个非目标值赋值到目标值的位置即可 使用双指针，一个从头开始遍历，一个从最后开始遍历，如果左指针值是目标值，则把右指针的值赋值到左指针，右指针向前一位，左指针不变再判断是否是目标值，如果不是则左指针向后走，直到两个指针相遇后，判断目标值是否是目标值，因为没有可以赋值的值了，所以如果是，返回的长度就-1(因为初始left的位置是0，所以抵消了) 临界值处理，当左右指针相同的时候，如果判断这个位置值不是目标值，则会再+1，再返回，因为left的开始值是0 时间复杂度O(n)，空间复杂度O(1) 答案 func removeElement(nums []int, val int) int { left, right := 0, len(nums)-1 for left 买卖股票的最佳时机 题目 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 用例 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 思路 最佳买卖一定是区间范围内最低点买最高点卖，那么假设我在之前的最低点买入，今天卖了如果赚的多了就存起来，遍历完每天即可得出结果 那么从第一天开始，这一天为最低点，后面每一天都先判断如果最低点买了，今天卖赚多少如果高于最大值则存起来，在判断今天是否比之前最低点更便宜，如果是那么今天之后开始假设今天买入即可 时间复杂度O(n)，空间复杂度O(1) 答案 func maxProfit(prices []int) int { if len(prices) "},"Algorithm/Medium.html":{"url":"Algorithm/Medium.html","title":"中等难度","keywords":"","body":"中等难度 最长回文子串 题目 给你一个字符串 s，找到 s 中最长的回文子串。 用例 输入：s = \"babad\" 输出：\"bab\" 输入：s = \"abb\" 输出：\"bb\" 思路 遍历整个字符串，以一个字符为中心，向外扩展，比对两侧的字符是否一致，如果一致，则宽度扩增一点，直到不一致，或者到达字符串边缘 但是如果回文长度是偶数，没有中心，那么就没法实现，解决方法是在每个字符中间加个特殊字符#，这样得到的回文一定是奇数，只需要最后把#去掉即可 top即为中心点的编号位置，length即为宽度，那么最后的结果，即为top-length+1的位置的值，到top+length的位置的值 在左侧+1的原因是，length是++后判断是否符合要求，也就是说，边界的值是第一个不符合情况的值，所以需要+1 而右侧因为本来需要-1，又+1，则抵消了 Manacher算法是最优算法，通过臂长再利用已算数据，但是我没细究这个算法 时间复杂度O(n^2)，空间复杂度O(n) 答案 func longestPalindrome(s string) string { if len(s) == 1 { return s } var ( maxCentor, maxLength = 0, 0 tmpStr = \"#\" ans = \"\" ) for i := 0; i = length && centor + length maxLength{ maxCentor = centor maxLength = length } } for i := maxCentor-maxLength+1; i 无重复字符的最长子串 题目 给定一个字符串 s ，请你找出其中不含有重复字符的 最长连续子字符串 的长度。 用例 输入: s = \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子字符串是 \"abc\"，所以其长度为 3。 输入: s = \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 思路 左右指针遍历整个字符串，左指针是开始，右指针是结束位置，当发现右指针的值出现过，则左指针向前推进到上次出现的位置再向后推进即可 为了减少判断是否出现过的情况，用哈希表存储所有出现过的值，右指针发现一个不在里面的删掉一个，左指针删除值 每次右指针变化，判断当前子串长度是否超过历史最高，如果超过则更新最长串 需要注意，因为字符串的长度，是结束位置-开始位置+1，其是数木桩需要连头连尾 时间复杂度O(n)，空间复杂度O(m)，m为最长子串的长度 答案 func lengthOfLongestSubstring(s string) int { var ( max = 0 m = map[byte]int{} start,end = 0, 0 ) for ;end max { max = end - start + 1 } } return max } 两数相加 题目 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 用例 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. 输入：l1 = [0], l2 = [0] 输出：[0] 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1] 思路 模拟竖式加法的方法，两个链表，同步向后推进，每个位置做加法计算，对10求余得到个位数，除以10得到向前进位的值 需要两个指针，一个是head，记录整个链表的头位置，一个是tail跟随l1和l2遍历，记录相加得到的值并记录next的位置 需要注意，如果最后一次加完之后依然有进位，需要再最后再新增一个节点记录 时间复杂度O(max(m,n))，空间复杂度O(1) 答案 func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { var( add = 0 head *ListNode tail *ListNode ) for l1 != nil || l2 != nil { n1, n2 := 0, 0 if l1 != nil { n1 = l1.Val l1 = l1.Next } if l2 != nil { n2 = l2.Val l2 = l2.Next } sum := (n1 + n2 + add) % 10 add = (n1 + n2 + add) / 10 if head == nil { head = &ListNode{Val: sum} tail = head } else { tail.Next = &ListNode{Val: sum} tail = tail.Next } } if add > 0 { tail.Next = &ListNode{Val: add} } return head } 括号生成 题目 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 用例 输入：n = 3 输出：[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"] 输入：n = 1 输出：[\"()\"] 思路 使用递归的方法，从高维向下递归到低维，直到0的时候，则为空返回即可 核心理论是，任何一组括号开头必然是(，那么n组括号可以拆解为(a)b，a+b=n-1，a和b分别是低于n的括号的排列组合 优化时间的方法，是将已经算过的低维的所有括号的排列组合的数组存到哈希表中，后面需要的时候直接调用即可，不用递归再组合出来 n=1的括号排列个数固定，可以优化也可以不优化，影响不大 时间复杂度O(2^n)，空间复杂度O(4^n) 答案 var generatrMap = make(map[int][]string) func generateParenthesis(n int) []string { var ( list = make([]string, 0) ) if n == 0 { return []string{\"\"} } if n == 1 { return []string{\"()\"} } if _, ok := generatrMap[n] ; ok{ return generatrMap[n] } for _n := 0 ; _n LRU 缓存 题目 请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。 实现 LRUCache 类： LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。 用例 输入 [\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] 输出 [null, null, null, 1, null, -1, null, -1, 3, 4] 解释 LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // 缓存是 {1=1} lRUCache.put(2, 2); // 缓存是 {1=1, 2=2} lRUCache.get(1); // 返回 1 lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3} lRUCache.get(2); // 返回 -1 (未找到) lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3} lRUCache.get(1); // 返回 -1 (未找到) lRUCache.get(3); // 返回 3 lRUCache.get(4); // 返回 4 思路 一个基础功能的算法处理，LRU即为最低使用淘汰的缓存算法 思路逻辑，使用一个双向链表串联一个哈希表，get数据的时候可以通过哈希快速获取到，每次get或者put只需要将该节点放置到链表头，需要删除的时候只需要将链表尾部去掉接口 注意点： 结构体中需要记录好最大长度、头指针、尾指针的位置 (下面的算法将头尾指针模拟为空，只做标识) 节点中，除了上下游指针，还有key，value，其中key主要是为了删除节点的时候需要知道其哈希编号 如果是删除节点除了链表移除还需要在hash表中移除 初始化的时候，需要将头指针的next、尾指针的prev设置好 移除节点的逻辑: 将节点的前节点的next指向后节点，后节点的prev指向前街店 节点加到头部的逻辑: 头指针的后节点先和目标节点挂钩，再把头指针的next指向目标节点即可 将节点移动到头部: 先移除节点，再将其加入头节点 Get操作，先判断有没有，没有的话返回-1，有的话，将节点移动到头部返回值 Put操作，先判断有没有，有的话和Get基本逻辑相似，没有的话，添加链表，如果长度高于limit，则删除尾节点 时间复杂度O(1)，空间复杂度O(n)，n为缓存的最大值 答案 type LRUCache struct { limit int head, tail *LinkNode data map[int]*LinkNode } type LinkNode struct { key, value int prev, next *LinkNode } func Constructor(capacity int) LRUCache { l := LRUCache{ data: make(map[int]*LinkNode), head: &LinkNode{}, tail: &LinkNode{}, limit: capacity, } l.head.next = l.tail l.tail.prev = l.head return l } func (this *LRUCache) addToHead(node *LinkNode) { node.prev = this.head node.next = this.head.next this.head.next.prev = node this.head.next = node } func (this *LRUCache) removeNode(node *LinkNode) { node.prev.next = node.next node.next.prev = node.prev } func (this *LRUCache) moveToHead(node *LinkNode) { this.removeNode(node) this.addToHead(node) } func (this *LRUCache) removeTail() { node := this.tail.prev this.removeNode(node) delete(this.data, node.key) } func (this *LRUCache) Get(key int) int { if _data, ok := this.data[key]; ok { this.moveToHead(_data) return _data.value } return -1 } func (this *LRUCache) Put(key int, value int) { if _data, ok := this.data[key]; ok { this.moveToHead(_data) _data.value = value return } if len(this.data) >= this.limit { this.removeTail() } this.data[key] = &LinkNode{ key: key, value: value, } this.addToHead(this.data[key]) } 二叉树的锯齿形层序遍历 题目 给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 用例 输入：root = [3,9,20,null,null,15,7] 输出：[[3],[20,9],[15,7]] 输入：root = [1] 输出：[[1]] 思路 核心思路是广义遍历整个二叉树，，一层一层的循环遍历，先不考虑锯齿形完成遍历 遍历树的算法: 通过队列记录每个层节点的的信息，从左往右 遍历的时候，将队列信息存入临时对象中，队列置空，当遍历当前节点没有一个子节点，队列没值即可退出 每层将所有节点的左节点、右节点依次存入队列中 时间复杂度O(n)，空间复杂度O(n) 答案 func zigzagLevelOrder(root *TreeNode) [][]int { if root == nil { return nil } var ( ans = [][]int{} list = []*TreeNode{root} ) for depth := 1; len(list) > 0; depth ++ { _l := list _data := []int{} list = nil for _, _n := range _l { _data = append(_data, _n.Val) if _n.Left != nil { list = append(list, _n.Left) } if _n.Right != nil { list = append(list, _n.Right) } } if depth %2 == 0 { _n := len(_data) for n := 0; n 整数反转 题目 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−2^31, 2^31 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 用例 输入：x = 123 输出：321 输入：x = -123 输出：-321 输入：x = 0 输出：0 思路 模拟堆栈，将数字对10求余，将数据插入已算结果的最后，然后将数字最后一位移除 数据模拟堆栈操作 获取出栈： x = x % 10 移除出栈： x /= 10 入栈： x = x*10 + a 需要注意，题目中，超过31位的时候直接返回0的要求 时间复杂度O(log∣x∣)，空间复杂度O(1) 答案 var ( ans = 0 ) for x!= 0 { if ans math.MaxInt32/10 { return 0 } a := x % 10 x /= 10 ans = ans*10 + a } return ans 三数之和 题目 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 用例 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 输入：nums = [] 输出：[] 输入：nums = [0] 输出：[] 思路 核心难点在于不重复如何保证不重复算，处理方法是，先排序再双指针遍历整个串即可 算法逻辑： 数组排序 设置一号指针，从前往后遍历，代表三值中最小值 设置二号指针，每次都是从一号指针后一位开始向后遍历，知道和三号指针相遇(因为相遇后再向后一定也不可能找到正确值)，代表三值中中间值 设置三号指针，每次都是从数组最后向前遍历，直到符合三个指针相加符合要求，代表三值中最大值 时间复杂度O(n^2)，空间复杂度O(log(n)) 答案 func threeSum(nums []int) [][]int { n := len(nums) sort.Ints(nums) ans := make([][]int, 0) for first := 0; first 0 && nums[first] == nums[first - 1] { continue } third := n - 1 target := -1 * nums[first] for second := first + 1; second first + 1 && nums[second] == nums[second - 1] { continue } for second target { third-- } if second == third { break } if nums[second] + nums[third] == target { ans = append(ans, []int{nums[first], nums[second], nums[third]}) } } } return ans } 搜索旋转排序数组 题目 整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。 用例 输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4 输入：nums = [4,5,6,7,0,1,2], target = 3 输出：-1 输入：nums = [1], target = 0 输出：-1 思路 整体采用二分法，每次从中裁取分开，判断三个值，数组头的值、中间值和目标值的大小关系 和直接二分法的区别在于，头部值是一个区分点，整体数据值在坐标系里面是两个线，会在一个值断开 其中和直接二分法不同的，有以下两个情况 如果中间值大于头部值，那么小于头部值的目标值一定在右边 如果攻坚之小于头部值，那么大于头部值的目标值一定在左边 下面写的题解中，将三个关键值排列组合，一共6中可能分别考虑到 需要注意，因为整个匹配中没有考虑相等情况，所以头部值需要先匹配是否是目标值 时间复杂度O(log(n))，空间复杂度O(1) 答案 func search(nums []int, target int) int { var ( top_number = nums[0] start, end = 0, len(nums) - 1 ) if top_number == target{ return 0 } for start 字符串相乘 题目 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。 用例 输入: num1 = \"2\", num2 = \"3\" 输出: \"6\" 输入: num1 = \"123\", num2 = \"456\" 输出: \"56088\" 思路 模拟乘法竖式表，需要注意，字符串的下标和真实数字位数不一致，所以len(num)-i才是数字所在位数 乘法即为，两个数字中，i号位 * j号位的数组 得到的是i+j位置的数字，注意这里的位数都是0为个位数 需要注意0可以提前处理，strconv.Itoa是int转化为string的方法 时间复杂度O(mn)，空间复杂度O(m+n) 答案 func multiply(num1 string, num2 string) string { if num1 == \"0\" || num2 == \"0\" { return \"0\" } var ( data = map[int]int{} _num1 = len(num1)-1 _num2 = len(num2) - 1 ans = \"\" ) for i := len(num1) - 1; i >= 0; i-- { for j := len(num2) - 1; j >= 0; j-- { _d := int(num1[i]-'0') * int(num2[j]-'0') _t := _num1 + _num2 - i - j data[_t] += _d % 10 _add := data[_t]/10 + _d/10 if _add != 0 { data[_t+1] += _add } data[_t] = data[_t] % 10 } } for i := len(data) - 1; i >= 0; i-- { ans += strconv.Itoa(data[i]) } return ans } 最长连续序列 题目 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 用例 输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 输入：nums = [0,3,7,2,5,8,4,6,0,1] 输出：9 思路 通过哈希表，保证快速判断值是否存在于列表中 思路即为，找到连续数的一个头，即没有比他大一或小一的值，这样可以保证不会重复算 具体算法即为，当一个值，没有比他大一的值，则判断，是否有比他小一的，有就一直向下遍历到头，再存入最大的长度值 时间复杂度O(n)，空间复杂度O(n) 答案 func longestConsecutive(nums []int) int { var ( num_list = map[int]bool{} ans = 1 ) if len(nums) == 0 { return 0 } for _, num := range nums { num_list[num] = true } for _d := range num_list{ if !num_list[_d+1]{ _length := 1 for num_list[_d-_length]{ _length ++ } if _length > ans { ans = _length } } } return ans } 乘积最大子数组 题目 给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 测试用例的答案是一个 32-位 整数。 子数组 是数组的连续子序列。 用例 输入: nums = [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。 输入: nums = [-2,0,-1] 输出: 0 解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 思路 整体思路和搜索旋转排序数组类似，一共有三个值需要考虑 当前值，如果之前乘积累计结果为0的时候，就需要舍弃之前连续的乘积，(题目要求的是子串所以必须连续) 最大值，保存这当前计算下面连续到现在的最大值的情况，(ans存储的是可能已经断开的最大值，这个是连续的) 最小值，保存当前计算下面连续到现在的最小值的情况，(主要是为了负负得正做准备，最小的数一定是负负得正后最大的数) 所以整个计算过程中，主需要比较当前值、当前值*最大值、当前值*最小值中的最大存入最大之中，最小存入最小中 时间复杂度O(n)，空间复杂度O(1) 答案 func maxProduct(nums []int) int { var ( ans, max, min = nums[0], nums[0], nums[0] ) for i := 1; i = _min && _min >= nums[i] { max = _max min = nums[i] } else if _max >= nums[i] && nums[i] >= _min { max = _max min = _min } else if _min >= nums[i] && nums[i] >= _max { max = _min min = _max } else if _min >= _max && _max >= nums[i] { max = _min min = nums[i] } else if nums[i] >= _max && _max >= _min { max = nums[i] min = _min } else if nums[i] >= _min && _min >= _max { max = nums[i] min = _max } if max > ans { ans = max } } return ans } 岛屿数量 题目 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 用例 输入：grid = [ [\"1\",\"1\",\"1\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"0\",\"0\"] ] 输出：1 输入：grid = [ [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"1\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"1\",\"1\"] ] 输出：3 思路 核心思路是，递归进行连接抹黑，当发现一个陆地可以直接岛屿数量+1，然后将其所有相连的陆地全部抹黑，改成水 这样完成图片的遍历，如果发现陆地他一定不被已遍历的陆地连接着 算法简析： 遍历每个格子，如果为1则表示岛屿数量+1 然后递归这个格子上下左右，四个方向的格子，如果格子存在且其值不为0，则表示陆地连接，将其改为0之后，遍历其上下左右的格子 需要注意，长是二阶数组的长度，款是二阶数组中任意一个值的一阶数组的长度 时间复杂度O(mn)，空间复杂度O(mn) 答案 func checkAllInOneLand(grid [][]byte, x, y int) { if x >= len(grid) || x = len(grid[x]) || y 最长递增子序列 题目 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 用例 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 输入：nums = [0,1,0,3,2,3] 输出：4 思路 核心逻辑思路是，贪心算法，每次尽可能把小的数组吸纳进来，这样排出的数字才最长 逻辑细则，用一个数组存储，最长的各个位置最小值情况的序列，因为题目要求递增，所以要保证这个数组递增 当数组为空、或者数组存储的最大值(数组最后一位的值)比遍历到的值还要小的时候，插入该数字 当这个值比最小值小的时候丢弃 当这个值比数组中最大值小的时候，寻找一个位置i，这个数list(i)，那么将i位置的数替换成这个数，这样可以继续保持数组的递增规则 寻找位置的时候，因为数组是顺序排列，最优解便是二分查找 设定一个start和一个end，中间位置(start+end)/2 如果目标值大于中间位置，那么start向前到mid位置，反之亦然 如果中间值正好是目标值，则直接返回，不需要改动 当start 说明中间还有值，则继续遍历 最后尽心替换的时候 如果目标值被正好找到，则说明有一样的值在列表中，不需要懂 如果目标值大于start位置的值，则将end位置替换，反之将start位置替换 时间复杂度O(nlog(n))，空间复杂度O(n) 答案 func lengthOfLIS(nums []int) int { var ( best_list []int ) for _, _n := range nums { if len(best_list) == 0 || best_list[len(best_list)-1] best_list[mid] { _start = mid } else if _n = _n { best_list[_start] = _n } else { best_list[_end] = _n } } return len(best_list) } 加油站 题目 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。 用例 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2] 输出: 3 解释: 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。 思路 核心思路，如果可以从m向前走n步，但第n+m+1位置走不过去，那么只需要从n+m+2位置重新开始尝试即可 因为n+m+1的位置走不过去至少可以肯定其gas值小于cost，那么这个位置不需要考虑作为起点 因为从m出发可以走n步，说明起点位置gas一定大于cost，那么再这n步已走的位置如果作为起点，到达n+m+1的位置，余留的值一定小于从m出发的值 算法逻辑，遍历两个长度相同的数组 其实位置，从0开始如果到最后一位的时候没有过去，则返回-1 记录向前走n步收集到的油和使用的油，如果收集值大于使用值，直接返回，其实位置向前推进n 时间复杂度O(n)，空间复杂度O(1) 答案 func canCompleteCircuit(gas []int, cost []int) int { nodes := len(cost) for i := 0; i 合并区间 题目 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 用例 输入：intervals = [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 输入：intervals = [[1,4],[4,5]] 输出：[[1,5]] 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 思路 核心思路，按照左区间的值进行排序，遍历过程中，一定是从小到大进行判断，如果要区间合并那么一定是存储的数组中的最后一个区间与至合并 算法逻辑 将区间数组按照左区间的大小进行排序 用ans存储区间结果 如果ans为空，或者其最后一位的右区间小于遍历到的区间的左区间，说明区间不相交，直接新增即可 如果最后一位的右区间大于等于遍历到的区间的左区间，那么区间相交，需要合并 如果相交的区间，目标区间的右区间小于ans的右区间，说明目标区间被包含，那么就不需要进行操作 时间复杂度O(nlog(n))，空间复杂度O(n) 答案 func merge(intervals [][]int) [][]int { var ( ans = [][]int{} ) sort.Slice(intervals, func(i, j int)bool{ return intervals[i][0] ans[len(ans)-1][1]{ ans[len(ans)-1] = []int{ans[len(ans)-1][0], intervals[i][1]} } } return ans } "},"Algorithm/Difficulty.html":{"url":"Algorithm/Difficulty.html","title":"困难难度","keywords":"","body":"困难难度 接雨水 题目 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 用例 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 输入：height = [4,2,0,3,2,5] 输出：9 思路 水的高度，是水槽左右两边高度中，较小的一个一个值决定的，所以需要定位出最高值，那么这个top的两侧就可以蓄水 左右两边指针同时向内靠拢，小的值向内走，最终汇聚在最高值上 虽然不知道最高值，但是左右两侧中小的值一定不是最高值，其位置向内变小的值一定可以蓄水 左右两侧分别记录左侧经历的最高值，和右侧遍历的当前最高值 如果遍历到的位置低于当前侧记录到的最高值，那么单侧最高值-当前位置即为该位置存的水 因为遍历该测的前提是另一侧的值更高，所以低于单侧最高值的位置一定会存水 时间复杂度O(n)，空间复杂度O(1) 答案 func trap(height []int) int { left, right := 0, len(height) - 1 ans := 0 leftMax, rightMax := 0, 0 for left = leftMax { leftMax = height[left] } else { ans += leftMax - height[left] } left ++ } else { if height[right] >= rightMax { rightMax = height[right] } else { ans += rightMax - height[right] } right -- } } return ans } K 个一组翻转链表 题目 用例 思路 时间复杂度O(n)，空间复杂度O(n) 答案 "}}